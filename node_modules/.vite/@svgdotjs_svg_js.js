var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};

// node_modules/@svgdotjs/svg.js/src/utils/methods.js
var methods = {};
var names = [];
function registerMethods(name, m) {
  if (Array.isArray(name)) {
    for (const _name of name) {
      registerMethods(_name, m);
    }
    return;
  }
  if (typeof name === "object") {
    for (const _name in name) {
      registerMethods(_name, name[_name]);
    }
    return;
  }
  addMethodNames(Object.getOwnPropertyNames(m));
  methods[name] = Object.assign(methods[name] || {}, m);
}
function getMethodsFor(name) {
  return methods[name] || {};
}
function getMethodNames() {
  return [...new Set(names)];
}
function addMethodNames(_names) {
  names.push(..._names);
}

// node_modules/@svgdotjs/svg.js/src/utils/utils.js
var utils_exports = {};
__export(utils_exports, {
  camelCase: () => camelCase,
  capitalize: () => capitalize,
  degrees: () => degrees,
  filter: () => filter,
  getOrigin: () => getOrigin,
  map: () => map,
  proportionalSize: () => proportionalSize,
  radians: () => radians,
  unCamelCase: () => unCamelCase
});
function map(array2, block) {
  var i;
  var il = array2.length;
  var result = [];
  for (i = 0; i < il; i++) {
    result.push(block(array2[i]));
  }
  return result;
}
function filter(array2, block) {
  var i;
  var il = array2.length;
  var result = [];
  for (i = 0; i < il; i++) {
    if (block(array2[i])) {
      result.push(array2[i]);
    }
  }
  return result;
}
function radians(d) {
  return d % 360 * Math.PI / 180;
}
function degrees(r) {
  return r * 180 / Math.PI % 360;
}
function camelCase(s) {
  return s.toLowerCase().replace(/-(.)/g, function(m, g) {
    return g.toUpperCase();
  });
}
function unCamelCase(s) {
  return s.replace(/([A-Z])/g, function(m, g) {
    return "-" + g.toLowerCase();
  });
}
function capitalize(s) {
  return s.charAt(0).toUpperCase() + s.slice(1);
}
function proportionalSize(element, width3, height3, box) {
  if (width3 == null || height3 == null) {
    box = box || element.bbox();
    if (width3 == null) {
      width3 = box.width / box.height * height3;
    } else if (height3 == null) {
      height3 = box.height / box.width * width3;
    }
  }
  return {
    width: width3,
    height: height3
  };
}
function getOrigin(o, element) {
  const origin = o.origin;
  let ox, oy;
  if (typeof origin === "string" || origin == null) {
    const string = (origin || "center").toLowerCase().trim();
    const {height: height3, width: width3, x: x3, y: y3} = element.bbox();
    const bx = string.includes("left") ? x3 : string.includes("right") ? x3 + width3 : x3 + width3 / 2;
    const by = string.includes("top") ? y3 : string.includes("bottom") ? y3 + height3 : y3 + height3 / 2;
    ox = o.ox != null ? o.ox : bx;
    oy = o.oy != null ? o.oy : by;
  } else {
    ox = origin[0];
    oy = origin[1];
  }
  return [ox, oy];
}

// node_modules/@svgdotjs/svg.js/src/modules/core/namespaces.js
var namespaces_exports = {};
__export(namespaces_exports, {
  ns: () => ns,
  svgjs: () => svgjs,
  xlink: () => xlink,
  xmlns: () => xmlns
});
var ns = "http://www.w3.org/2000/svg";
var xmlns = "http://www.w3.org/2000/xmlns/";
var xlink = "http://www.w3.org/1999/xlink";
var svgjs = "http://svgjs.com/svgjs";

// node_modules/@svgdotjs/svg.js/src/utils/window.js
var globals = {
  window: typeof window === "undefined" ? null : window,
  document: typeof document === "undefined" ? null : document
};
function registerWindow(win = null, doc = null) {
  globals.window = win;
  globals.document = doc;
}

// node_modules/@svgdotjs/svg.js/src/types/Base.js
var Base = class {
};
var Base_default = Base;

// node_modules/@svgdotjs/svg.js/src/utils/adopter.js
var elements = {};
var root = "___SYMBOL___ROOT___";
function create(name) {
  return globals.document.createElementNS(ns, name);
}
function makeInstance(element) {
  if (element instanceof Base_default)
    return element;
  if (typeof element === "object") {
    return adopter(element);
  }
  if (element == null) {
    return new elements[root]();
  }
  if (typeof element === "string" && element.charAt(0) !== "<") {
    return adopter(globals.document.querySelector(element));
  }
  var node = create("svg");
  node.innerHTML = element;
  element = adopter(node.firstChild);
  return element;
}
function nodeOrNew(name, node) {
  return node instanceof globals.window.Node ? node : create(name);
}
function adopt(node) {
  if (!node)
    return null;
  if (node.instance instanceof Base_default)
    return node.instance;
  var className = capitalize(node.nodeName || "Dom");
  if (className === "LinearGradient" || className === "RadialGradient") {
    className = "Gradient";
  } else if (!elements[className]) {
    className = "Dom";
  }
  return new elements[className](node);
}
var adopter = adopt;
function mockAdopt(mock = adopt) {
  adopter = mock;
}
function register(element, name = element.name, asRoot = false) {
  elements[name] = element;
  if (asRoot)
    elements[root] = element;
  addMethodNames(Object.getOwnPropertyNames(element.prototype));
  return element;
}
function getClass(name) {
  return elements[name];
}
var did = 1e3;
function eid(name) {
  return "Svgjs" + capitalize(name) + did++;
}
function assignNewId(node) {
  for (var i = node.children.length - 1; i >= 0; i--) {
    assignNewId(node.children[i]);
  }
  if (node.id) {
    return adopt(node).id(eid(node.nodeName));
  }
  return adopt(node);
}
function extend(modules, methods3, attrCheck) {
  var key, i;
  modules = Array.isArray(modules) ? modules : [modules];
  for (i = modules.length - 1; i >= 0; i--) {
    for (key in methods3) {
      let method = methods3[key];
      if (attrCheck) {
        method = wrapWithAttrCheck(methods3[key]);
      }
      modules[i].prototype[key] = method;
    }
  }
}
function wrapWithAttrCheck(fn) {
  return function(...args) {
    const o = args[args.length - 1];
    if (o && o.constructor === Object && !(o instanceof Array)) {
      return fn.apply(this, args.slice(0, -1)).attr(o);
    } else {
      return fn.apply(this, args);
    }
  };
}
function invent(config) {
  var initializer = typeof config.create === "function" ? config.create : function(node) {
    this.constructor(node || create(config.create));
  };
  if (config.inherit) {
    initializer.prototype = new config.inherit();
    initializer.prototype.constructor = initializer;
  }
  if (config.extend) {
    extend(initializer, config.extend);
  }
  if (config.construct) {
    extend(config.parent || elements.Container, config.construct);
  }
  return initializer;
}

// node_modules/@svgdotjs/svg.js/src/modules/optional/arrange.js
function siblings() {
  return this.parent().children();
}
function position() {
  return this.parent().index(this);
}
function next() {
  return this.siblings()[this.position() + 1];
}
function prev() {
  return this.siblings()[this.position() - 1];
}
function forward() {
  var i = this.position() + 1;
  var p = this.parent();
  p.removeElement(this).add(this, i);
  if (typeof p.isRoot === "function" && p.isRoot()) {
    p.node.appendChild(p.defs().node);
  }
  return this;
}
function backward() {
  var i = this.position();
  if (i > 0) {
    this.parent().removeElement(this).add(this, i - 1);
  }
  return this;
}
function front() {
  var p = this.parent();
  p.node.appendChild(this.node);
  if (typeof p.isRoot === "function" && p.isRoot()) {
    p.node.appendChild(p.defs().node);
  }
  return this;
}
function back() {
  if (this.position() > 0) {
    this.parent().removeElement(this).add(this, 0);
  }
  return this;
}
function before(element) {
  element = makeInstance(element);
  element.remove();
  var i = this.position();
  this.parent().add(element, i);
  return this;
}
function after(element) {
  element = makeInstance(element);
  element.remove();
  var i = this.position();
  this.parent().add(element, i + 1);
  return this;
}
function insertBefore(element) {
  element = makeInstance(element);
  element.before(this);
  return this;
}
function insertAfter(element) {
  element = makeInstance(element);
  element.after(this);
  return this;
}
registerMethods("Dom", {
  siblings,
  position,
  next,
  prev,
  forward,
  backward,
  front,
  back,
  before,
  after,
  insertBefore,
  insertAfter
});

// node_modules/@svgdotjs/svg.js/src/modules/core/regex.js
var regex_exports = {};
__export(regex_exports, {
  delimiter: () => delimiter,
  dots: () => dots,
  hex: () => hex,
  hyphen: () => hyphen,
  isBlank: () => isBlank,
  isCss: () => isCss,
  isHex: () => isHex,
  isImage: () => isImage,
  isNumber: () => isNumber,
  isPathLetter: () => isPathLetter,
  isPercent: () => isPercent,
  isRgb: () => isRgb,
  numberAndUnit: () => numberAndUnit,
  numbersWithDots: () => numbersWithDots,
  pathLetters: () => pathLetters,
  reference: () => reference,
  rgb: () => rgb,
  transforms: () => transforms,
  whitespace: () => whitespace
});
var numberAndUnit = /^([+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?)([a-z%]*)$/i;
var hex = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i;
var rgb = /rgb\((\d+),(\d+),(\d+)\)/;
var reference = /(#[a-z0-9\-_]+)/i;
var transforms = /\)\s*,?\s*/;
var whitespace = /\s/g;
var isHex = /^#[a-f0-9]{3,6}$/i;
var isRgb = /^rgb\(/;
var isCss = /[^:]+:[^;]+;?/;
var isBlank = /^(\s+)?$/;
var isNumber = /^[+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
var isPercent = /^-?[\d.]+%$/;
var isImage = /\.(jpg|jpeg|png|gif|svg)(\?[^=]+.*)?/i;
var delimiter = /[\s,]+/;
var hyphen = /([^e])-/gi;
var pathLetters = /[MLHVCSQTAZ]/gi;
var isPathLetter = /[MLHVCSQTAZ]/i;
var numbersWithDots = /((\d?\.\d+(?:e[+-]?\d+)?)((?:\.\d+(?:e[+-]?\d+)?)+))+/gi;
var dots = /\./g;

// node_modules/@svgdotjs/svg.js/src/modules/optional/class.js
function classes() {
  var attr2 = this.attr("class");
  return attr2 == null ? [] : attr2.trim().split(delimiter);
}
function hasClass(name) {
  return this.classes().indexOf(name) !== -1;
}
function addClass(name) {
  if (!this.hasClass(name)) {
    var array2 = this.classes();
    array2.push(name);
    this.attr("class", array2.join(" "));
  }
  return this;
}
function removeClass(name) {
  if (this.hasClass(name)) {
    this.attr("class", this.classes().filter(function(c) {
      return c !== name;
    }).join(" "));
  }
  return this;
}
function toggleClass(name) {
  return this.hasClass(name) ? this.removeClass(name) : this.addClass(name);
}
registerMethods("Dom", {
  classes,
  hasClass,
  addClass,
  removeClass,
  toggleClass
});

// node_modules/@svgdotjs/svg.js/src/modules/optional/css.js
function css(style, val) {
  const ret = {};
  if (arguments.length === 0) {
    this.node.style.cssText.split(/\s*;\s*/).filter(function(el) {
      return !!el.length;
    }).forEach(function(el) {
      const t = el.split(/\s*:\s*/);
      ret[t[0]] = t[1];
    });
    return ret;
  }
  if (arguments.length < 2) {
    if (Array.isArray(style)) {
      for (const name of style) {
        const cased = camelCase(name);
        ret[cased] = this.node.style[cased];
      }
      return ret;
    }
    if (typeof style === "string") {
      return this.node.style[camelCase(style)];
    }
    if (typeof style === "object") {
      for (const name in style) {
        this.node.style[camelCase(name)] = style[name] == null || isBlank.test(style[name]) ? "" : style[name];
      }
    }
  }
  if (arguments.length === 2) {
    this.node.style[camelCase(style)] = val == null || isBlank.test(val) ? "" : val;
  }
  return this;
}
function show() {
  return this.css("display", "");
}
function hide() {
  return this.css("display", "none");
}
function visible() {
  return this.css("display") !== "none";
}
registerMethods("Dom", {
  css,
  show,
  hide,
  visible
});

// node_modules/@svgdotjs/svg.js/src/modules/optional/data.js
function data(a, v, r) {
  if (typeof a === "object") {
    for (v in a) {
      this.data(v, a[v]);
    }
  } else if (arguments.length < 2) {
    try {
      return JSON.parse(this.attr("data-" + a));
    } catch (e) {
      return this.attr("data-" + a);
    }
  } else {
    this.attr("data-" + a, v === null ? null : r === true || typeof v === "string" || typeof v === "number" ? v : JSON.stringify(v));
  }
  return this;
}
registerMethods("Dom", {data});

// node_modules/@svgdotjs/svg.js/src/modules/optional/memory.js
function remember(k, v) {
  if (typeof arguments[0] === "object") {
    for (var key in k) {
      this.remember(key, k[key]);
    }
  } else if (arguments.length === 1) {
    return this.memory()[k];
  } else {
    this.memory()[k] = v;
  }
  return this;
}
function forget() {
  if (arguments.length === 0) {
    this._memory = {};
  } else {
    for (var i = arguments.length - 1; i >= 0; i--) {
      delete this.memory()[arguments[i]];
    }
  }
  return this;
}
function memory() {
  return this._memory = this._memory || {};
}
registerMethods("Dom", {remember, forget, memory});

// node_modules/@svgdotjs/svg.js/src/modules/core/event.js
var listenerId = 0;
var windowEvents = {};
function getEvents(instance) {
  let n = instance.getEventHolder();
  if (n === globals.window)
    n = windowEvents;
  if (!n.events)
    n.events = {};
  return n.events;
}
function getEventTarget(instance) {
  return instance.getEventTarget();
}
function clearEvents(instance) {
  const n = instance.getEventHolder();
  if (n.events)
    n.events = {};
}
function on(node, events, listener, binding, options) {
  var l = listener.bind(binding || node);
  var instance = makeInstance(node);
  var bag = getEvents(instance);
  var n = getEventTarget(instance);
  events = Array.isArray(events) ? events : events.split(delimiter);
  if (!listener._svgjsListenerId) {
    listener._svgjsListenerId = ++listenerId;
  }
  events.forEach(function(event) {
    var ev = event.split(".")[0];
    var ns2 = event.split(".")[1] || "*";
    bag[ev] = bag[ev] || {};
    bag[ev][ns2] = bag[ev][ns2] || {};
    bag[ev][ns2][listener._svgjsListenerId] = l;
    n.addEventListener(ev, l, options || false);
  });
}
function off(node, events, listener, options) {
  var instance = makeInstance(node);
  var bag = getEvents(instance);
  var n = getEventTarget(instance);
  if (typeof listener === "function") {
    listener = listener._svgjsListenerId;
    if (!listener)
      return;
  }
  events = Array.isArray(events) ? events : (events || "").split(delimiter);
  events.forEach(function(event) {
    var ev = event && event.split(".")[0];
    var ns2 = event && event.split(".")[1];
    var namespace, l;
    if (listener) {
      if (bag[ev] && bag[ev][ns2 || "*"]) {
        n.removeEventListener(ev, bag[ev][ns2 || "*"][listener], options || false);
        delete bag[ev][ns2 || "*"][listener];
      }
    } else if (ev && ns2) {
      if (bag[ev] && bag[ev][ns2]) {
        for (l in bag[ev][ns2]) {
          off(n, [ev, ns2].join("."), l);
        }
        delete bag[ev][ns2];
      }
    } else if (ns2) {
      for (event in bag) {
        for (namespace in bag[event]) {
          if (ns2 === namespace) {
            off(n, [event, ns2].join("."));
          }
        }
      }
    } else if (ev) {
      if (bag[ev]) {
        for (namespace in bag[ev]) {
          off(n, [ev, namespace].join("."));
        }
        delete bag[ev];
      }
    } else {
      for (event in bag) {
        off(n, event);
      }
      clearEvents(instance);
    }
  });
}
function dispatch(node, event, data2) {
  var n = getEventTarget(node);
  if (event instanceof globals.window.Event) {
    n.dispatchEvent(event);
  } else {
    event = new globals.window.CustomEvent(event, {detail: data2, cancelable: true});
    n.dispatchEvent(event);
  }
  return event;
}

// node_modules/@svgdotjs/svg.js/src/types/Color.js
function sixDigitHex(hex2) {
  return hex2.length === 4 ? [
    "#",
    hex2.substring(1, 2),
    hex2.substring(1, 2),
    hex2.substring(2, 3),
    hex2.substring(2, 3),
    hex2.substring(3, 4),
    hex2.substring(3, 4)
  ].join("") : hex2;
}
function componentHex(component) {
  const integer = Math.round(component);
  const bounded = Math.max(0, Math.min(255, integer));
  const hex2 = bounded.toString(16);
  return hex2.length === 1 ? "0" + hex2 : hex2;
}
function is(object, space) {
  for (let i = space.length; i--; ) {
    if (object[space[i]] == null) {
      return false;
    }
  }
  return true;
}
function getParameters(a, b) {
  const params = is(a, "rgb") ? {_a: a.r, _b: a.g, _c: a.b, space: "rgb"} : is(a, "xyz") ? {_a: a.x, _b: a.y, _c: a.z, _d: 0, space: "xyz"} : is(a, "hsl") ? {_a: a.h, _b: a.s, _c: a.l, _d: 0, space: "hsl"} : is(a, "lab") ? {_a: a.l, _b: a.a, _c: a.b, _d: 0, space: "lab"} : is(a, "lch") ? {_a: a.l, _b: a.c, _c: a.h, _d: 0, space: "lch"} : is(a, "cmyk") ? {_a: a.c, _b: a.m, _c: a.y, _d: a.k, space: "cmyk"} : {_a: 0, _b: 0, _c: 0, space: "rgb"};
  params.space = b || params.space;
  return params;
}
function cieSpace(space) {
  if (space === "lab" || space === "xyz" || space === "lch") {
    return true;
  } else {
    return false;
  }
}
function hueToRgb(p, q, t) {
  if (t < 0)
    t += 1;
  if (t > 1)
    t -= 1;
  if (t < 1 / 6)
    return p + (q - p) * 6 * t;
  if (t < 1 / 2)
    return q;
  if (t < 2 / 3)
    return p + (q - p) * (2 / 3 - t) * 6;
  return p;
}
var Color = class {
  constructor(...inputs) {
    this.init(...inputs);
  }
  init(a = 0, b = 0, c = 0, d = 0, space = "rgb") {
    a = !a ? 0 : a;
    if (this.space) {
      for (const component in this.space) {
        delete this[this.space[component]];
      }
    }
    if (typeof a === "number") {
      space = typeof d === "string" ? d : space;
      d = typeof d === "string" ? 0 : d;
      Object.assign(this, {_a: a, _b: b, _c: c, _d: d, space});
    } else if (a instanceof Array) {
      this.space = b || (typeof a[3] === "string" ? a[3] : a[4]) || "rgb";
      Object.assign(this, {_a: a[0], _b: a[1], _c: a[2], _d: a[3] || 0});
    } else if (a instanceof Object) {
      const values = getParameters(a, b);
      Object.assign(this, values);
    } else if (typeof a === "string") {
      if (isRgb.test(a)) {
        const noWhitespace = a.replace(whitespace, "");
        const [_a2, _b2, _c2] = rgb.exec(noWhitespace).slice(1, 4).map((v) => parseInt(v));
        Object.assign(this, {_a: _a2, _b: _b2, _c: _c2, _d: 0, space: "rgb"});
      } else if (isHex.test(a)) {
        const hexParse = (v) => parseInt(v, 16);
        const [, _a2, _b2, _c2] = hex.exec(sixDigitHex(a)).map(hexParse);
        Object.assign(this, {_a: _a2, _b: _b2, _c: _c2, _d: 0, space: "rgb"});
      } else
        throw Error("Unsupported string format, can't construct Color");
    }
    const {_a, _b, _c, _d} = this;
    const components = this.space === "rgb" ? {r: _a, g: _b, b: _c} : this.space === "xyz" ? {x: _a, y: _b, z: _c} : this.space === "hsl" ? {h: _a, s: _b, l: _c} : this.space === "lab" ? {l: _a, a: _b, b: _c} : this.space === "lch" ? {l: _a, c: _b, h: _c} : this.space === "cmyk" ? {c: _a, m: _b, y: _c, k: _d} : {};
    Object.assign(this, components);
  }
  rgb() {
    if (this.space === "rgb") {
      return this;
    } else if (cieSpace(this.space)) {
      let {x: x3, y: y3, z} = this;
      if (this.space === "lab" || this.space === "lch") {
        let {l, a, b: b2} = this;
        if (this.space === "lch") {
          const {c, h} = this;
          const dToR = Math.PI / 180;
          a = c * Math.cos(dToR * h);
          b2 = c * Math.sin(dToR * h);
        }
        const yL = (l + 16) / 116;
        const xL = a / 500 + yL;
        const zL = yL - b2 / 200;
        const ct = 16 / 116;
        const mx = 8856e-6;
        const nm = 7.787;
        x3 = 0.95047 * (xL ** 3 > mx ? xL ** 3 : (xL - ct) / nm);
        y3 = 1 * (yL ** 3 > mx ? yL ** 3 : (yL - ct) / nm);
        z = 1.08883 * (zL ** 3 > mx ? zL ** 3 : (zL - ct) / nm);
      }
      const rU = x3 * 3.2406 + y3 * -1.5372 + z * -0.4986;
      const gU = x3 * -0.9689 + y3 * 1.8758 + z * 0.0415;
      const bU = x3 * 0.0557 + y3 * -0.204 + z * 1.057;
      const pow = Math.pow;
      const bd = 31308e-7;
      const r = rU > bd ? 1.055 * pow(rU, 1 / 2.4) - 0.055 : 12.92 * rU;
      const g = gU > bd ? 1.055 * pow(gU, 1 / 2.4) - 0.055 : 12.92 * gU;
      const b = bU > bd ? 1.055 * pow(bU, 1 / 2.4) - 0.055 : 12.92 * bU;
      const color = new Color(255 * r, 255 * g, 255 * b);
      return color;
    } else if (this.space === "hsl") {
      let {h, s, l} = this;
      h /= 360;
      s /= 100;
      l /= 100;
      if (s === 0) {
        l *= 255;
        const color2 = new Color(l, l, l);
        return color2;
      }
      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      const p = 2 * l - q;
      const r = 255 * hueToRgb(p, q, h + 1 / 3);
      const g = 255 * hueToRgb(p, q, h);
      const b = 255 * hueToRgb(p, q, h - 1 / 3);
      const color = new Color(r, g, b);
      return color;
    } else if (this.space === "cmyk") {
      const {c, m, y: y3, k} = this;
      const r = 255 * (1 - Math.min(1, c * (1 - k) + k));
      const g = 255 * (1 - Math.min(1, m * (1 - k) + k));
      const b = 255 * (1 - Math.min(1, y3 * (1 - k) + k));
      const color = new Color(r, g, b);
      return color;
    } else {
      return this;
    }
  }
  lab() {
    const {x: x3, y: y3, z} = this.xyz();
    const l = 116 * y3 - 16;
    const a = 500 * (x3 - y3);
    const b = 200 * (y3 - z);
    const color = new Color(l, a, b, "lab");
    return color;
  }
  xyz() {
    const {_a: r255, _b: g255, _c: b255} = this.rgb();
    const [r, g, b] = [r255, g255, b255].map((v) => v / 255);
    const rL = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
    const gL = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
    const bL = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
    const xU = (rL * 0.4124 + gL * 0.3576 + bL * 0.1805) / 0.95047;
    const yU = (rL * 0.2126 + gL * 0.7152 + bL * 0.0722) / 1;
    const zU = (rL * 0.0193 + gL * 0.1192 + bL * 0.9505) / 1.08883;
    const x3 = xU > 8856e-6 ? Math.pow(xU, 1 / 3) : 7.787 * xU + 16 / 116;
    const y3 = yU > 8856e-6 ? Math.pow(yU, 1 / 3) : 7.787 * yU + 16 / 116;
    const z = zU > 8856e-6 ? Math.pow(zU, 1 / 3) : 7.787 * zU + 16 / 116;
    const color = new Color(x3, y3, z, "xyz");
    return color;
  }
  lch() {
    const {l, a, b} = this.lab();
    const c = Math.sqrt(a ** 2 + b ** 2);
    let h = 180 * Math.atan2(b, a) / Math.PI;
    if (h < 0) {
      h *= -1;
      h = 360 - h;
    }
    const color = new Color(l, c, h, "lch");
    return color;
  }
  hsl() {
    const {_a, _b, _c} = this.rgb();
    const [r, g, b] = [_a, _b, _c].map((v) => v / 255);
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    const l = (max + min) / 2;
    const isGrey = max === min;
    const delta = max - min;
    const s = isGrey ? 0 : l > 0.5 ? delta / (2 - max - min) : delta / (max + min);
    const h = isGrey ? 0 : max === r ? ((g - b) / delta + (g < b ? 6 : 0)) / 6 : max === g ? ((b - r) / delta + 2) / 6 : max === b ? ((r - g) / delta + 4) / 6 : 0;
    const color = new Color(360 * h, 100 * s, 100 * l, "hsl");
    return color;
  }
  cmyk() {
    const {_a, _b, _c} = this.rgb();
    const [r, g, b] = [_a, _b, _c].map((v) => v / 255);
    const k = Math.min(1 - r, 1 - g, 1 - b);
    if (k === 1) {
      return new Color(0, 0, 0, 1, "cmyk");
    }
    const c = (1 - r - k) / (1 - k);
    const m = (1 - g - k) / (1 - k);
    const y3 = (1 - b - k) / (1 - k);
    const color = new Color(c, m, y3, k, "cmyk");
    return color;
  }
  _clamped() {
    const {_a, _b, _c} = this.rgb();
    const {max, min, round} = Math;
    const format = (v) => max(0, min(round(v), 255));
    return [_a, _b, _c].map(format);
  }
  toHex() {
    const [r, g, b] = this._clamped().map(componentHex);
    return `#${r}${g}${b}`;
  }
  toString() {
    return this.toHex();
  }
  toRgb() {
    const [rV, gV, bV] = this._clamped();
    const string = `rgb(${rV},${gV},${bV})`;
    return string;
  }
  toArray() {
    const {_a, _b, _c, _d, space} = this;
    return [_a, _b, _c, _d, space];
  }
  static random(mode = "vibrant", t, u) {
    const {random, round, sin, PI: pi} = Math;
    if (mode === "vibrant") {
      const l = (81 - 57) * random() + 57;
      const c = (83 - 45) * random() + 45;
      const h = 360 * random();
      const color = new Color(l, c, h, "lch");
      return color;
    } else if (mode === "sine") {
      t = t == null ? random() : t;
      const r = round(80 * sin(2 * pi * t / 0.5 + 0.01) + 150);
      const g = round(50 * sin(2 * pi * t / 0.5 + 4.6) + 200);
      const b = round(100 * sin(2 * pi * t / 0.5 + 2.3) + 150);
      const color = new Color(r, g, b);
      return color;
    } else if (mode === "pastel") {
      const l = (94 - 86) * random() + 86;
      const c = (26 - 9) * random() + 9;
      const h = 360 * random();
      const color = new Color(l, c, h, "lch");
      return color;
    } else if (mode === "dark") {
      const l = 10 + 10 * random();
      const c = (125 - 75) * random() + 86;
      const h = 360 * random();
      const color = new Color(l, c, h, "lch");
      return color;
    } else if (mode === "rgb") {
      const r = 255 * random();
      const g = 255 * random();
      const b = 255 * random();
      const color = new Color(r, g, b);
      return color;
    } else if (mode === "lab") {
      const l = 100 * random();
      const a = 256 * random() - 128;
      const b = 256 * random() - 128;
      const color = new Color(l, a, b, "lab");
      return color;
    } else if (mode === "grey") {
      const grey = 255 * random();
      const color = new Color(grey, grey, grey);
      return color;
    }
  }
  static test(color) {
    return typeof color === "string" && (isHex.test(color) || isRgb.test(color));
  }
  static isRgb(color) {
    return color && typeof color.r === "number" && typeof color.g === "number" && typeof color.b === "number";
  }
  static isColor(color) {
    return color && (color instanceof Color || this.isRgb(color) || this.test(color));
  }
};
var Color_default = Color;

// node_modules/@svgdotjs/svg.js/src/types/Point.js
var Point = class {
  constructor(...args) {
    this.init(...args);
  }
  init(x3, y3) {
    const base = {x: 0, y: 0};
    const source = Array.isArray(x3) ? {x: x3[0], y: x3[1]} : typeof x3 === "object" ? {x: x3.x, y: x3.y} : {x: x3, y: y3};
    this.x = source.x == null ? base.x : source.x;
    this.y = source.y == null ? base.y : source.y;
    return this;
  }
  clone() {
    return new Point(this);
  }
  transform(m) {
    return this.clone().transformO(m);
  }
  transformO(m) {
    if (!Matrix_default.isMatrixLike(m)) {
      m = new Matrix_default(m);
    }
    const {x: x3, y: y3} = this;
    this.x = m.a * x3 + m.c * y3 + m.e;
    this.y = m.b * x3 + m.d * y3 + m.f;
    return this;
  }
  toArray() {
    return [this.x, this.y];
  }
};
var Point_default = Point;
function point(x3, y3) {
  return new Point(x3, y3).transform(this.screenCTM().inverse());
}

// node_modules/@svgdotjs/svg.js/src/types/Matrix.js
function closeEnough(a, b, threshold) {
  return Math.abs(b - a) < (threshold || 1e-6);
}
var Matrix = class {
  constructor(...args) {
    this.init(...args);
  }
  init(source) {
    var base = Matrix.fromArray([1, 0, 0, 1, 0, 0]);
    source = source instanceof Element_default ? source.matrixify() : typeof source === "string" ? Matrix.fromArray(source.split(delimiter).map(parseFloat)) : Array.isArray(source) ? Matrix.fromArray(source) : typeof source === "object" && Matrix.isMatrixLike(source) ? source : typeof source === "object" ? new Matrix().transform(source) : arguments.length === 6 ? Matrix.fromArray([].slice.call(arguments)) : base;
    this.a = source.a != null ? source.a : base.a;
    this.b = source.b != null ? source.b : base.b;
    this.c = source.c != null ? source.c : base.c;
    this.d = source.d != null ? source.d : base.d;
    this.e = source.e != null ? source.e : base.e;
    this.f = source.f != null ? source.f : base.f;
    return this;
  }
  clone() {
    return new Matrix(this);
  }
  transform(o) {
    if (Matrix.isMatrixLike(o)) {
      var matrix = new Matrix(o);
      return matrix.multiplyO(this);
    }
    var t = Matrix.formatTransforms(o);
    var current = this;
    const {x: ox, y: oy} = new Point_default(t.ox, t.oy).transform(current);
    var transformer = new Matrix().translateO(t.rx, t.ry).lmultiplyO(current).translateO(-ox, -oy).scaleO(t.scaleX, t.scaleY).skewO(t.skewX, t.skewY).shearO(t.shear).rotateO(t.theta).translateO(ox, oy);
    if (isFinite(t.px) || isFinite(t.py)) {
      const origin = new Point_default(ox, oy).transform(transformer);
      const dx = t.px ? t.px - origin.x : 0;
      const dy = t.py ? t.py - origin.y : 0;
      transformer.translateO(dx, dy);
    }
    transformer.translateO(t.tx, t.ty);
    return transformer;
  }
  compose(o) {
    if (o.origin) {
      o.originX = o.origin[0];
      o.originY = o.origin[1];
    }
    var ox = o.originX || 0;
    var oy = o.originY || 0;
    var sx = o.scaleX || 1;
    var sy = o.scaleY || 1;
    var lam = o.shear || 0;
    var theta = o.rotate || 0;
    var tx = o.translateX || 0;
    var ty = o.translateY || 0;
    var result = new Matrix().translateO(-ox, -oy).scaleO(sx, sy).shearO(lam).rotateO(theta).translateO(tx, ty).lmultiplyO(this).translateO(ox, oy);
    return result;
  }
  decompose(cx2 = 0, cy2 = 0) {
    var a = this.a;
    var b = this.b;
    var c = this.c;
    var d = this.d;
    var e = this.e;
    var f = this.f;
    var determinant = a * d - b * c;
    var ccw = determinant > 0 ? 1 : -1;
    var sx = ccw * Math.sqrt(a * a + b * b);
    var thetaRad = Math.atan2(ccw * b, ccw * a);
    var theta = 180 / Math.PI * thetaRad;
    var ct = Math.cos(thetaRad);
    var st = Math.sin(thetaRad);
    var lam = (a * c + b * d) / determinant;
    var sy = c * sx / (lam * a - b) || d * sx / (lam * b + a);
    const tx = e - cx2 + cx2 * ct * sx + cy2 * (lam * ct * sx - st * sy);
    const ty = f - cy2 + cx2 * st * sx + cy2 * (lam * st * sx + ct * sy);
    return {
      scaleX: sx,
      scaleY: sy,
      shear: lam,
      rotate: theta,
      translateX: tx,
      translateY: ty,
      originX: cx2,
      originY: cy2,
      a: this.a,
      b: this.b,
      c: this.c,
      d: this.d,
      e: this.e,
      f: this.f
    };
  }
  multiply(matrix) {
    return this.clone().multiplyO(matrix);
  }
  multiplyO(matrix) {
    var l = this;
    var r = matrix instanceof Matrix ? matrix : new Matrix(matrix);
    return Matrix.matrixMultiply(l, r, this);
  }
  lmultiply(matrix) {
    return this.clone().lmultiplyO(matrix);
  }
  lmultiplyO(matrix) {
    var r = this;
    var l = matrix instanceof Matrix ? matrix : new Matrix(matrix);
    return Matrix.matrixMultiply(l, r, this);
  }
  inverseO() {
    var a = this.a;
    var b = this.b;
    var c = this.c;
    var d = this.d;
    var e = this.e;
    var f = this.f;
    var det = a * d - b * c;
    if (!det)
      throw new Error("Cannot invert " + this);
    var na = d / det;
    var nb = -b / det;
    var nc = -c / det;
    var nd = a / det;
    var ne = -(na * e + nc * f);
    var nf = -(nb * e + nd * f);
    this.a = na;
    this.b = nb;
    this.c = nc;
    this.d = nd;
    this.e = ne;
    this.f = nf;
    return this;
  }
  inverse() {
    return this.clone().inverseO();
  }
  translate(x3, y3) {
    return this.clone().translateO(x3, y3);
  }
  translateO(x3, y3) {
    this.e += x3 || 0;
    this.f += y3 || 0;
    return this;
  }
  scale(x3, y3, cx2, cy2) {
    return this.clone().scaleO(...arguments);
  }
  scaleO(x3, y3 = x3, cx2 = 0, cy2 = 0) {
    if (arguments.length === 3) {
      cy2 = cx2;
      cx2 = y3;
      y3 = x3;
    }
    const {a, b, c, d, e, f} = this;
    this.a = a * x3;
    this.b = b * y3;
    this.c = c * x3;
    this.d = d * y3;
    this.e = e * x3 - cx2 * x3 + cx2;
    this.f = f * y3 - cy2 * y3 + cy2;
    return this;
  }
  rotate(r, cx2, cy2) {
    return this.clone().rotateO(r, cx2, cy2);
  }
  rotateO(r, cx2 = 0, cy2 = 0) {
    r = radians(r);
    const cos = Math.cos(r);
    const sin = Math.sin(r);
    const {a, b, c, d, e, f} = this;
    this.a = a * cos - b * sin;
    this.b = b * cos + a * sin;
    this.c = c * cos - d * sin;
    this.d = d * cos + c * sin;
    this.e = e * cos - f * sin + cy2 * sin - cx2 * cos + cx2;
    this.f = f * cos + e * sin - cx2 * sin - cy2 * cos + cy2;
    return this;
  }
  flip(axis, around) {
    return this.clone().flipO(axis, around);
  }
  flipO(axis, around) {
    return axis === "x" ? this.scaleO(-1, 1, around, 0) : axis === "y" ? this.scaleO(1, -1, 0, around) : this.scaleO(-1, -1, axis, around || axis);
  }
  shear(a, cx2, cy2) {
    return this.clone().shearO(a, cx2, cy2);
  }
  shearO(lx, cx2 = 0, cy2 = 0) {
    const {a, b, c, d, e, f} = this;
    this.a = a + b * lx;
    this.c = c + d * lx;
    this.e = e + f * lx - cy2 * lx;
    return this;
  }
  skew(x3, y3, cx2, cy2) {
    return this.clone().skewO(...arguments);
  }
  skewO(x3, y3 = x3, cx2 = 0, cy2 = 0) {
    if (arguments.length === 3) {
      cy2 = cx2;
      cx2 = y3;
      y3 = x3;
    }
    x3 = radians(x3);
    y3 = radians(y3);
    const lx = Math.tan(x3);
    const ly = Math.tan(y3);
    const {a, b, c, d, e, f} = this;
    this.a = a + b * lx;
    this.b = b + a * ly;
    this.c = c + d * lx;
    this.d = d + c * ly;
    this.e = e + f * lx - cy2 * lx;
    this.f = f + e * ly - cx2 * ly;
    return this;
  }
  skewX(x3, cx2, cy2) {
    return this.skew(x3, 0, cx2, cy2);
  }
  skewXO(x3, cx2, cy2) {
    return this.skewO(x3, 0, cx2, cy2);
  }
  skewY(y3, cx2, cy2) {
    return this.skew(0, y3, cx2, cy2);
  }
  skewYO(y3, cx2, cy2) {
    return this.skewO(0, y3, cx2, cy2);
  }
  aroundO(cx2, cy2, matrix) {
    var dx = cx2 || 0;
    var dy = cy2 || 0;
    return this.translateO(-dx, -dy).lmultiplyO(matrix).translateO(dx, dy);
  }
  around(cx2, cy2, matrix) {
    return this.clone().aroundO(cx2, cy2, matrix);
  }
  equals(other) {
    var comp = new Matrix(other);
    return closeEnough(this.a, comp.a) && closeEnough(this.b, comp.b) && closeEnough(this.c, comp.c) && closeEnough(this.d, comp.d) && closeEnough(this.e, comp.e) && closeEnough(this.f, comp.f);
  }
  toString() {
    return "matrix(" + this.a + "," + this.b + "," + this.c + "," + this.d + "," + this.e + "," + this.f + ")";
  }
  toArray() {
    return [this.a, this.b, this.c, this.d, this.e, this.f];
  }
  valueOf() {
    return {
      a: this.a,
      b: this.b,
      c: this.c,
      d: this.d,
      e: this.e,
      f: this.f
    };
  }
  static fromArray(a) {
    return {a: a[0], b: a[1], c: a[2], d: a[3], e: a[4], f: a[5]};
  }
  static isMatrixLike(o) {
    return o.a != null || o.b != null || o.c != null || o.d != null || o.e != null || o.f != null;
  }
  static formatTransforms(o) {
    var flipBoth = o.flip === "both" || o.flip === true;
    var flipX = o.flip && (flipBoth || o.flip === "x") ? -1 : 1;
    var flipY = o.flip && (flipBoth || o.flip === "y") ? -1 : 1;
    var skewX = o.skew && o.skew.length ? o.skew[0] : isFinite(o.skew) ? o.skew : isFinite(o.skewX) ? o.skewX : 0;
    var skewY = o.skew && o.skew.length ? o.skew[1] : isFinite(o.skew) ? o.skew : isFinite(o.skewY) ? o.skewY : 0;
    var scaleX = o.scale && o.scale.length ? o.scale[0] * flipX : isFinite(o.scale) ? o.scale * flipX : isFinite(o.scaleX) ? o.scaleX * flipX : flipX;
    var scaleY = o.scale && o.scale.length ? o.scale[1] * flipY : isFinite(o.scale) ? o.scale * flipY : isFinite(o.scaleY) ? o.scaleY * flipY : flipY;
    var shear = o.shear || 0;
    var theta = o.rotate || o.theta || 0;
    var origin = new Point_default(o.origin || o.around || o.ox || o.originX, o.oy || o.originY);
    var ox = origin.x;
    var oy = origin.y;
    var position2 = new Point_default(o.position || o.px || o.positionX, o.py || o.positionY);
    var px = position2.x;
    var py = position2.y;
    var translate = new Point_default(o.translate || o.tx || o.translateX, o.ty || o.translateY);
    var tx = translate.x;
    var ty = translate.y;
    var relative = new Point_default(o.relative || o.rx || o.relativeX, o.ry || o.relativeY);
    var rx2 = relative.x;
    var ry2 = relative.y;
    return {
      scaleX,
      scaleY,
      skewX,
      skewY,
      shear,
      theta,
      rx: rx2,
      ry: ry2,
      tx,
      ty,
      ox,
      oy,
      px,
      py
    };
  }
  static matrixMultiply(l, r, o) {
    var a = l.a * r.a + l.c * r.b;
    var b = l.b * r.a + l.d * r.b;
    var c = l.a * r.c + l.c * r.d;
    var d = l.b * r.c + l.d * r.d;
    var e = l.e + l.a * r.e + l.c * r.f;
    var f = l.f + l.b * r.e + l.d * r.f;
    o.a = a;
    o.b = b;
    o.c = c;
    o.d = d;
    o.e = e;
    o.f = f;
    return o;
  }
};
var Matrix_default = Matrix;
function ctm() {
  return new Matrix(this.node.getCTM());
}
function screenCTM() {
  if (typeof this.isRoot === "function" && !this.isRoot()) {
    var rect = this.rect(1, 1);
    var m = rect.node.getScreenCTM();
    rect.remove();
    return new Matrix(m);
  }
  return new Matrix(this.node.getScreenCTM());
}
register(Matrix, "Matrix");

// node_modules/@svgdotjs/svg.js/src/modules/core/parser.js
function parser() {
  if (!parser.nodes) {
    const svg = makeInstance().size(2, 0);
    svg.node.style.cssText = [
      "opacity: 0",
      "position: absolute",
      "left: -100%",
      "top: -100%",
      "overflow: hidden"
    ].join(";");
    svg.attr("focusable", "false");
    svg.attr("aria-hidden", "true");
    const path = svg.path().node;
    parser.nodes = {svg, path};
  }
  if (!parser.nodes.svg.node.parentNode) {
    const b = globals.document.body || globals.document.documentElement;
    parser.nodes.svg.addTo(b);
  }
  return parser.nodes;
}

// node_modules/@svgdotjs/svg.js/src/types/Box.js
function isNulledBox(box) {
  return !box.width && !box.height && !box.x && !box.y;
}
function domContains(node) {
  return node === globals.document || (globals.document.documentElement.contains || function(node2) {
    while (node2.parentNode) {
      node2 = node2.parentNode;
    }
    return node2 === globals.document;
  }).call(globals.document.documentElement, node);
}
var Box = class {
  constructor(...args) {
    this.init(...args);
  }
  init(source) {
    var base = [0, 0, 0, 0];
    source = typeof source === "string" ? source.split(delimiter).map(parseFloat) : Array.isArray(source) ? source : typeof source === "object" ? [source.left != null ? source.left : source.x, source.top != null ? source.top : source.y, source.width, source.height] : arguments.length === 4 ? [].slice.call(arguments) : base;
    this.x = source[0] || 0;
    this.y = source[1] || 0;
    this.width = this.w = source[2] || 0;
    this.height = this.h = source[3] || 0;
    this.x2 = this.x + this.w;
    this.y2 = this.y + this.h;
    this.cx = this.x + this.w / 2;
    this.cy = this.y + this.h / 2;
    return this;
  }
  merge(box) {
    const x3 = Math.min(this.x, box.x);
    const y3 = Math.min(this.y, box.y);
    const width3 = Math.max(this.x + this.width, box.x + box.width) - x3;
    const height3 = Math.max(this.y + this.height, box.y + box.height) - y3;
    return new Box(x3, y3, width3, height3);
  }
  transform(m) {
    if (!(m instanceof Matrix_default)) {
      m = new Matrix_default(m);
    }
    let xMin = Infinity;
    let xMax = -Infinity;
    let yMin = Infinity;
    let yMax = -Infinity;
    const pts = [
      new Point_default(this.x, this.y),
      new Point_default(this.x2, this.y),
      new Point_default(this.x, this.y2),
      new Point_default(this.x2, this.y2)
    ];
    pts.forEach(function(p) {
      p = p.transform(m);
      xMin = Math.min(xMin, p.x);
      xMax = Math.max(xMax, p.x);
      yMin = Math.min(yMin, p.y);
      yMax = Math.max(yMax, p.y);
    });
    return new Box(xMin, yMin, xMax - xMin, yMax - yMin);
  }
  addOffset() {
    this.x += globals.window.pageXOffset;
    this.y += globals.window.pageYOffset;
    return this;
  }
  toString() {
    return this.x + " " + this.y + " " + this.width + " " + this.height;
  }
  toArray() {
    return [this.x, this.y, this.width, this.height];
  }
  isNulled() {
    return isNulledBox(this);
  }
};
var Box_default = Box;
function getBox(cb, retry) {
  let box;
  try {
    box = cb(this.node);
    if (isNulledBox(box) && !domContains(this.node)) {
      throw new Error("Element not in the dom");
    }
  } catch (e) {
    box = retry(this);
  }
  return box;
}
function bbox() {
  return new Box(getBox.call(this, (node) => node.getBBox(), (el) => {
    try {
      const clone = el.clone().addTo(parser().svg).show();
      const box = clone.node.getBBox();
      clone.remove();
      return box;
    } catch (e) {
      throw new Error('Getting bbox of element "' + el.node.nodeName + '" is not possible. ' + e.toString());
    }
  }));
}
function rbox(el) {
  const box = new Box(getBox.call(this, (node) => node.getBoundingClientRect(), (el2) => {
    throw new Error('Getting rbox of element "' + el2.node.nodeName + '" is not possible');
  }));
  if (el)
    return box.transform(el.screenCTM().inverse());
  return box.addOffset();
}
registerMethods({
  viewbox: {
    viewbox(x3, y3, width3, height3) {
      if (x3 == null)
        return new Box(this.attr("viewBox"));
      return this.attr("viewBox", new Box(x3, y3, width3, height3));
    },
    zoom(level, point2) {
      let width3 = this.node.clientWidth;
      let height3 = this.node.clientHeight;
      const v = this.viewbox();
      if (!width3 && !height3) {
        var style = window.getComputedStyle(this.node);
        width3 = parseFloat(style.getPropertyValue("width"));
        height3 = parseFloat(style.getPropertyValue("height"));
      }
      const zoomX = width3 / v.width;
      const zoomY = height3 / v.height;
      const zoom = Math.min(zoomX, zoomY);
      if (level == null) {
        return zoom;
      }
      let zoomAmount = zoom / level;
      if (zoomAmount === Infinity)
        zoomAmount = Number.MIN_VALUE;
      point2 = point2 || new Point_default(width3 / 2 / zoomX + v.x, height3 / 2 / zoomY + v.y);
      const box = new Box(v).transform(new Matrix_default({scale: zoomAmount, origin: point2}));
      return this.viewbox(box);
    }
  }
});
register(Box, "Box");

// node_modules/@svgdotjs/svg.js/src/types/ArrayPolyfill.js
var subClassArray = function() {
  try {
    return Function("name", "baseClass", "_constructor", [
      "baseClass = baseClass || Array",
      "return {",
      "  [name]: class extends baseClass {",
      "    constructor (...args) {",
      "      super(...args)",
      "      _constructor && _constructor.apply(this, args)",
      "    }",
      "  }",
      "}[name]"
    ].join("\n"));
  } catch (e) {
    return (name, baseClass = Array, _constructor) => {
      const Arr = function() {
        baseClass.apply(this, arguments);
        _constructor && _constructor.apply(this, arguments);
      };
      Arr.prototype = Object.create(baseClass.prototype);
      Arr.prototype.constructor = Arr;
      Arr.prototype.map = function(fn) {
        const arr = new Arr();
        arr.push.apply(arr, Array.prototype.map.call(this, fn));
        return arr;
      };
      return Arr;
    };
  }
}();

// node_modules/@svgdotjs/svg.js/src/types/List.js
var List = subClassArray("List", Array, function(arr = []) {
  if (typeof arr === "number")
    return this;
  this.length = 0;
  this.push(...arr);
});
var List_default = List;
extend(List, {
  each(fnOrMethodName, ...args) {
    if (typeof fnOrMethodName === "function") {
      return this.map((el) => {
        return fnOrMethodName.call(el, el);
      });
    } else {
      return this.map((el) => {
        return el[fnOrMethodName](...args);
      });
    }
  },
  toArray() {
    return Array.prototype.concat.apply([], this);
  }
});
var reserved = ["toArray", "constructor", "each"];
List.extend = function(methods3) {
  methods3 = methods3.reduce((obj, name) => {
    if (reserved.includes(name))
      return obj;
    if (name[0] === "_")
      return obj;
    obj[name] = function(...attrs2) {
      return this.each(name, ...attrs2);
    };
    return obj;
  }, {});
  extend(List, methods3);
};

// node_modules/@svgdotjs/svg.js/src/modules/core/selector.js
function baseFind(query, parent) {
  return new List_default(map((parent || globals.document).querySelectorAll(query), function(node) {
    return adopt(node);
  }));
}
function find(query) {
  return baseFind(query, this.node);
}
function findOne(query) {
  return adopt(this.node.querySelector(query));
}

// node_modules/@svgdotjs/svg.js/src/types/EventTarget.js
var EventTarget = class extends Base_default {
  constructor({events = {}} = {}) {
    super();
    this.events = events;
  }
  addEventListener() {
  }
  dispatch(event, data2) {
    return dispatch(this, event, data2);
  }
  dispatchEvent(event) {
    const bag = this.getEventHolder().events;
    if (!bag)
      return true;
    const events = bag[event.type];
    for (const i in events) {
      for (const j in events[i]) {
        events[i][j](event);
      }
    }
    return !event.defaultPrevented;
  }
  fire(event, data2) {
    this.dispatch(event, data2);
    return this;
  }
  getEventHolder() {
    return this;
  }
  getEventTarget() {
    return this;
  }
  off(event, listener) {
    off(this, event, listener);
    return this;
  }
  on(event, listener, binding, options) {
    on(this, event, listener, binding, options);
    return this;
  }
  removeEventListener() {
  }
};
var EventTarget_default = EventTarget;
register(EventTarget, "EventTarget");

// node_modules/@svgdotjs/svg.js/src/modules/core/defaults.js
var defaults_exports = {};
__export(defaults_exports, {
  attrs: () => attrs,
  noop: () => noop,
  timeline: () => timeline
});
function noop() {
}
var timeline = {
  duration: 400,
  ease: ">",
  delay: 0
};
var attrs = {
  "fill-opacity": 1,
  "stroke-opacity": 1,
  "stroke-width": 0,
  "stroke-linejoin": "miter",
  "stroke-linecap": "butt",
  fill: "#000000",
  stroke: "#000000",
  opacity: 1,
  x: 0,
  y: 0,
  cx: 0,
  cy: 0,
  width: 0,
  height: 0,
  r: 0,
  rx: 0,
  ry: 0,
  offset: 0,
  "stop-opacity": 1,
  "stop-color": "#000000",
  "text-anchor": "start"
};

// node_modules/@svgdotjs/svg.js/src/types/SVGArray.js
var SVGArray = subClassArray("SVGArray", Array, function(arr) {
  this.init(arr);
});
var SVGArray_default = SVGArray;
extend(SVGArray, {
  init(arr) {
    if (typeof arr === "number")
      return this;
    this.length = 0;
    this.push(...this.parse(arr));
    return this;
  },
  toArray() {
    return Array.prototype.concat.apply([], this);
  },
  toString() {
    return this.join(" ");
  },
  valueOf() {
    const ret = [];
    ret.push(...this);
    return ret;
  },
  parse(array2 = []) {
    if (array2 instanceof Array)
      return array2;
    return array2.trim().split(delimiter).map(parseFloat);
  },
  clone() {
    return new this.constructor(this);
  },
  toSet() {
    return new Set(this);
  }
});

// node_modules/@svgdotjs/svg.js/src/types/SVGNumber.js
var SVGNumber = class {
  constructor(...args) {
    this.init(...args);
  }
  init(value, unit) {
    unit = Array.isArray(value) ? value[1] : unit;
    value = Array.isArray(value) ? value[0] : value;
    this.value = 0;
    this.unit = unit || "";
    if (typeof value === "number") {
      this.value = isNaN(value) ? 0 : !isFinite(value) ? value < 0 ? -34e37 : 34e37 : value;
    } else if (typeof value === "string") {
      unit = value.match(numberAndUnit);
      if (unit) {
        this.value = parseFloat(unit[1]);
        if (unit[5] === "%") {
          this.value /= 100;
        } else if (unit[5] === "s") {
          this.value *= 1e3;
        }
        this.unit = unit[5];
      }
    } else {
      if (value instanceof SVGNumber) {
        this.value = value.valueOf();
        this.unit = value.unit;
      }
    }
    return this;
  }
  toString() {
    return (this.unit === "%" ? ~~(this.value * 1e8) / 1e6 : this.unit === "s" ? this.value / 1e3 : this.value) + this.unit;
  }
  toJSON() {
    return this.toString();
  }
  toArray() {
    return [this.value, this.unit];
  }
  valueOf() {
    return this.value;
  }
  plus(number) {
    number = new SVGNumber(number);
    return new SVGNumber(this + number, this.unit || number.unit);
  }
  minus(number) {
    number = new SVGNumber(number);
    return new SVGNumber(this - number, this.unit || number.unit);
  }
  times(number) {
    number = new SVGNumber(number);
    return new SVGNumber(this * number, this.unit || number.unit);
  }
  divide(number) {
    number = new SVGNumber(number);
    return new SVGNumber(this / number, this.unit || number.unit);
  }
  convert(unit) {
    return new SVGNumber(this.value, unit);
  }
};
var SVGNumber_default = SVGNumber;

// node_modules/@svgdotjs/svg.js/src/modules/core/attr.js
var hooks = [];
function registerAttrHook(fn) {
  hooks.push(fn);
}
function attr(attr2, val, ns2) {
  if (attr2 == null) {
    attr2 = {};
    val = this.node.attributes;
    for (const node of val) {
      attr2[node.nodeName] = isNumber.test(node.nodeValue) ? parseFloat(node.nodeValue) : node.nodeValue;
    }
    return attr2;
  } else if (attr2 instanceof Array) {
    return attr2.reduce((last, curr) => {
      last[curr] = this.attr(curr);
      return last;
    }, {});
  } else if (typeof attr2 === "object" && attr2.constructor === Object) {
    for (val in attr2)
      this.attr(val, attr2[val]);
  } else if (val === null) {
    this.node.removeAttribute(attr2);
  } else if (val == null) {
    val = this.node.getAttribute(attr2);
    return val == null ? attrs[attr2] : isNumber.test(val) ? parseFloat(val) : val;
  } else {
    val = hooks.reduce((_val, hook) => {
      return hook(attr2, _val, this);
    }, val);
    if (typeof val === "number") {
      val = new SVGNumber_default(val);
    } else if (Color_default.isColor(val)) {
      val = new Color_default(val);
    } else if (val.constructor === Array) {
      val = new SVGArray_default(val);
    }
    if (attr2 === "leading") {
      if (this.leading) {
        this.leading(val);
      }
    } else {
      typeof ns2 === "string" ? this.node.setAttributeNS(ns2, attr2, val.toString()) : this.node.setAttribute(attr2, val.toString());
    }
    if (this.rebuild && (attr2 === "font-size" || attr2 === "x")) {
      this.rebuild();
    }
  }
  return this;
}

// node_modules/@svgdotjs/svg.js/src/elements/Dom.js
var Dom = class extends EventTarget_default {
  constructor(node, attrs2) {
    super(node);
    this.node = node;
    this.type = node.nodeName;
    if (attrs2 && node !== attrs2) {
      this.attr(attrs2);
    }
  }
  add(element, i) {
    element = makeInstance(element);
    if (i == null) {
      this.node.appendChild(element.node);
    } else if (element.node !== this.node.childNodes[i]) {
      this.node.insertBefore(element.node, this.node.childNodes[i]);
    }
    return this;
  }
  addTo(parent) {
    return makeInstance(parent).put(this);
  }
  children() {
    return new List_default(map(this.node.children, function(node) {
      return adopt(node);
    }));
  }
  clear() {
    while (this.node.hasChildNodes()) {
      this.node.removeChild(this.node.lastChild);
    }
    return this;
  }
  clone() {
    this.writeDataToDom();
    return assignNewId(this.node.cloneNode(true));
  }
  each(block, deep) {
    var children = this.children();
    var i, il;
    for (i = 0, il = children.length; i < il; i++) {
      block.apply(children[i], [i, children]);
      if (deep) {
        children[i].each(block, deep);
      }
    }
    return this;
  }
  element(nodeName) {
    return this.put(new Dom(create(nodeName)));
  }
  first() {
    return adopt(this.node.firstChild);
  }
  get(i) {
    return adopt(this.node.childNodes[i]);
  }
  getEventHolder() {
    return this.node;
  }
  getEventTarget() {
    return this.node;
  }
  has(element) {
    return this.index(element) >= 0;
  }
  id(id) {
    if (typeof id === "undefined" && !this.node.id) {
      this.node.id = eid(this.type);
    }
    return this.attr("id", id);
  }
  index(element) {
    return [].slice.call(this.node.childNodes).indexOf(element.node);
  }
  last() {
    return adopt(this.node.lastChild);
  }
  matches(selector) {
    const el = this.node;
    return (el.matches || el.matchesSelector || el.msMatchesSelector || el.mozMatchesSelector || el.webkitMatchesSelector || el.oMatchesSelector).call(el, selector);
  }
  parent(type) {
    var parent = this;
    if (!parent.node.parentNode)
      return null;
    parent = adopt(parent.node.parentNode);
    if (!type)
      return parent;
    while (parent) {
      if (typeof type === "string" ? parent.matches(type) : parent instanceof type)
        return parent;
      if (!parent.node.parentNode || parent.node.parentNode.nodeName === "#document" || parent.node.parentNode.nodeName === "#document-fragment")
        return null;
      parent = adopt(parent.node.parentNode);
    }
  }
  put(element, i) {
    this.add(element, i);
    return element;
  }
  putIn(parent) {
    return makeInstance(parent).add(this);
  }
  remove() {
    if (this.parent()) {
      this.parent().removeElement(this);
    }
    return this;
  }
  removeElement(element) {
    this.node.removeChild(element.node);
    return this;
  }
  replace(element) {
    element = makeInstance(element);
    this.node.parentNode.replaceChild(element.node, this.node);
    return element;
  }
  round(precision = 2, map2) {
    const factor = 10 ** precision;
    const attrs2 = this.attr();
    if (!map2) {
      map2 = Object.keys(attrs2);
    }
    const newAttrs = {};
    map2.forEach((key) => {
      newAttrs[key] = Math.round(attrs2[key] * factor) / factor;
    });
    this.attr(newAttrs);
    return this;
  }
  toString() {
    return this.id();
  }
  svg(svgOrFn, outerHTML) {
    var well, len, fragment;
    if (svgOrFn === false) {
      outerHTML = false;
      svgOrFn = null;
    }
    if (svgOrFn == null || typeof svgOrFn === "function") {
      outerHTML = outerHTML == null ? true : outerHTML;
      this.writeDataToDom();
      let current = this;
      if (svgOrFn != null) {
        current = adopt(current.node.cloneNode(true));
        if (outerHTML) {
          const result = svgOrFn(current);
          current = result || current;
          if (result === false)
            return "";
        }
        current.each(function() {
          const result = svgOrFn(this);
          const _this = result || this;
          if (result === false) {
            this.remove();
          } else if (result && this !== _this) {
            this.replace(_this);
          }
        }, true);
      }
      return outerHTML ? current.node.outerHTML : current.node.innerHTML;
    }
    outerHTML = outerHTML == null ? false : outerHTML;
    well = globals.document.createElementNS(ns, "svg");
    fragment = globals.document.createDocumentFragment();
    well.innerHTML = svgOrFn;
    for (len = well.children.length; len--; ) {
      fragment.appendChild(well.firstElementChild);
    }
    const parent = this.parent();
    return outerHTML ? this.replace(fragment) && parent : this.add(fragment);
  }
  words(text) {
    this.node.textContent = text;
    return this;
  }
  writeDataToDom() {
    this.each(function() {
      this.writeDataToDom();
    });
    return this;
  }
};
var Dom_default = Dom;
extend(Dom, {attr, find, findOne});
register(Dom, "Dom");

// node_modules/@svgdotjs/svg.js/src/elements/Element.js
var Element = class extends Dom_default {
  constructor(node, attrs2) {
    super(node, attrs2);
    this.dom = {};
    this.node.instance = this;
    if (node.hasAttribute("svgjs:data")) {
      this.setData(JSON.parse(node.getAttribute("svgjs:data")) || {});
    }
  }
  center(x3, y3) {
    return this.cx(x3).cy(y3);
  }
  cx(x3) {
    return x3 == null ? this.x() + this.width() / 2 : this.x(x3 - this.width() / 2);
  }
  cy(y3) {
    return y3 == null ? this.y() + this.height() / 2 : this.y(y3 - this.height() / 2);
  }
  defs() {
    return this.root().defs();
  }
  dmove(x3, y3) {
    return this.dx(x3).dy(y3);
  }
  dx(x3 = 0) {
    return this.x(new SVGNumber_default(x3).plus(this.x()));
  }
  dy(y3 = 0) {
    return this.y(new SVGNumber_default(y3).plus(this.y()));
  }
  root() {
    const p = this.parent(getClass(root));
    return p && p.root();
  }
  getEventHolder() {
    return this;
  }
  height(height3) {
    return this.attr("height", height3);
  }
  inside(x3, y3) {
    const box = this.bbox();
    return x3 > box.x && y3 > box.y && x3 < box.x + box.width && y3 < box.y + box.height;
  }
  move(x3, y3) {
    return this.x(x3).y(y3);
  }
  parents(until = globals.document) {
    until = makeInstance(until);
    const parents = new List_default();
    let parent = this;
    while ((parent = parent.parent()) && parent.node !== until.node && parent.node !== globals.document) {
      parents.push(parent);
    }
    return parents;
  }
  reference(attr2) {
    attr2 = this.attr(attr2);
    if (!attr2)
      return null;
    const m = attr2.match(reference);
    return m ? makeInstance(m[1]) : null;
  }
  setData(o) {
    this.dom = o;
    return this;
  }
  size(width3, height3) {
    const p = proportionalSize(this, width3, height3);
    return this.width(new SVGNumber_default(p.width)).height(new SVGNumber_default(p.height));
  }
  width(width3) {
    return this.attr("width", width3);
  }
  writeDataToDom() {
    this.node.removeAttribute("svgjs:data");
    if (Object.keys(this.dom).length) {
      this.node.setAttribute("svgjs:data", JSON.stringify(this.dom));
    }
    return super.writeDataToDom();
  }
  x(x3) {
    return this.attr("x", x3);
  }
  y(y3) {
    return this.attr("y", y3);
  }
};
var Element_default = Element;
extend(Element, {
  bbox,
  rbox,
  point,
  ctm,
  screenCTM
});
register(Element, "Element");

// node_modules/@svgdotjs/svg.js/src/modules/optional/sugar.js
var sugar = {
  stroke: ["color", "width", "opacity", "linecap", "linejoin", "miterlimit", "dasharray", "dashoffset"],
  fill: ["color", "opacity", "rule"],
  prefix: function(t, a) {
    return a === "color" ? t : t + "-" + a;
  }
};
["fill", "stroke"].forEach(function(m) {
  var extension = {};
  var i;
  extension[m] = function(o) {
    if (typeof o === "undefined") {
      return this.attr(m);
    }
    if (typeof o === "string" || o instanceof Color_default || Color_default.isRgb(o) || o instanceof Element_default) {
      this.attr(m, o);
    } else {
      for (i = sugar[m].length - 1; i >= 0; i--) {
        if (o[sugar[m][i]] != null) {
          this.attr(sugar.prefix(m, sugar[m][i]), o[sugar[m][i]]);
        }
      }
    }
    return this;
  };
  registerMethods(["Element", "Runner"], extension);
});
registerMethods(["Element", "Runner"], {
  matrix: function(mat, b, c, d, e, f) {
    if (mat == null) {
      return new Matrix_default(this);
    }
    return this.attr("transform", new Matrix_default(mat, b, c, d, e, f));
  },
  rotate: function(angle, cx2, cy2) {
    return this.transform({rotate: angle, ox: cx2, oy: cy2}, true);
  },
  skew: function(x3, y3, cx2, cy2) {
    return arguments.length === 1 || arguments.length === 3 ? this.transform({skew: x3, ox: y3, oy: cx2}, true) : this.transform({skew: [x3, y3], ox: cx2, oy: cy2}, true);
  },
  shear: function(lam, cx2, cy2) {
    return this.transform({shear: lam, ox: cx2, oy: cy2}, true);
  },
  scale: function(x3, y3, cx2, cy2) {
    return arguments.length === 1 || arguments.length === 3 ? this.transform({scale: x3, ox: y3, oy: cx2}, true) : this.transform({scale: [x3, y3], ox: cx2, oy: cy2}, true);
  },
  translate: function(x3, y3) {
    return this.transform({translate: [x3, y3]}, true);
  },
  relative: function(x3, y3) {
    return this.transform({relative: [x3, y3]}, true);
  },
  flip: function(direction, around) {
    var directionString = typeof direction === "string" ? direction : isFinite(direction) ? "both" : "both";
    var origin = direction === "both" && isFinite(around) ? [around, around] : direction === "x" ? [around, 0] : direction === "y" ? [0, around] : isFinite(direction) ? [direction, direction] : [0, 0];
    return this.transform({flip: directionString, origin}, true);
  },
  opacity: function(value) {
    return this.attr("opacity", value);
  }
});
registerMethods("radius", {
  radius: function(x3, y3) {
    var type = (this._element || this).type;
    return type === "radialGradient" || type === "radialGradient" ? this.attr("r", new SVGNumber_default(x3)) : this.rx(x3).ry(y3 == null ? x3 : y3);
  }
});
registerMethods("Path", {
  length: function() {
    return this.node.getTotalLength();
  },
  pointAt: function(length2) {
    return new Point_default(this.node.getPointAtLength(length2));
  }
});
registerMethods(["Element", "Runner"], {
  font: function(a, v) {
    if (typeof a === "object") {
      for (v in a)
        this.font(v, a[v]);
      return this;
    }
    return a === "leading" ? this.leading(v) : a === "anchor" ? this.attr("text-anchor", v) : a === "size" || a === "family" || a === "weight" || a === "stretch" || a === "variant" || a === "style" ? this.attr("font-" + a, v) : this.attr(a, v);
  }
});
registerMethods("Text", {
  ax(x3) {
    return this.attr("x", x3);
  },
  ay(y3) {
    return this.attr("y", y3);
  },
  amove(x3, y3) {
    return this.ax(x3).ay(y3);
  }
});
var methods2 = [
  "click",
  "dblclick",
  "mousedown",
  "mouseup",
  "mouseover",
  "mouseout",
  "mousemove",
  "mouseenter",
  "mouseleave",
  "touchstart",
  "touchmove",
  "touchleave",
  "touchend",
  "touchcancel"
].reduce(function(last, event) {
  const fn = function(f) {
    if (f === null) {
      off(this, event);
    } else {
      on(this, event, f);
    }
    return this;
  };
  last[event] = fn;
  return last;
}, {});
registerMethods("Element", methods2);

// node_modules/@svgdotjs/svg.js/src/modules/optional/transform.js
function untransform() {
  return this.attr("transform", null);
}
function matrixify() {
  var matrix = (this.attr("transform") || "").split(transforms).slice(0, -1).map(function(str) {
    var kv = str.trim().split("(");
    return [
      kv[0],
      kv[1].split(delimiter).map(function(str2) {
        return parseFloat(str2);
      })
    ];
  }).reverse().reduce(function(matrix2, transform2) {
    if (transform2[0] === "matrix") {
      return matrix2.lmultiply(Matrix_default.fromArray(transform2[1]));
    }
    return matrix2[transform2[0]].apply(matrix2, transform2[1]);
  }, new Matrix_default());
  return matrix;
}
function toParent(parent) {
  if (this === parent)
    return this;
  var ctm2 = this.screenCTM();
  var pCtm = parent.screenCTM().inverse();
  this.addTo(parent).untransform().transform(pCtm.multiply(ctm2));
  return this;
}
function toRoot() {
  return this.toParent(this.root());
}
function transform(o, relative) {
  if (o == null || typeof o === "string") {
    var decomposed = new Matrix_default(this).decompose();
    return o == null ? decomposed : decomposed[o];
  }
  if (!Matrix_default.isMatrixLike(o)) {
    o = {...o, origin: getOrigin(o, this)};
  }
  var cleanRelative = relative === true ? this : relative || false;
  var result = new Matrix_default(cleanRelative).transform(o);
  return this.attr("transform", result);
}
registerMethods("Element", {
  untransform,
  matrixify,
  toParent,
  toRoot,
  transform
});

// node_modules/@svgdotjs/svg.js/src/modules/core/circled.js
var circled_exports = {};
__export(circled_exports, {
  cx: () => cx,
  cy: () => cy,
  height: () => height,
  rx: () => rx,
  ry: () => ry,
  width: () => width,
  x: () => x,
  y: () => y
});
function rx(rx2) {
  return this.attr("rx", rx2);
}
function ry(ry2) {
  return this.attr("ry", ry2);
}
function x(x3) {
  return x3 == null ? this.cx() - this.rx() : this.cx(x3 + this.rx());
}
function y(y3) {
  return y3 == null ? this.cy() - this.ry() : this.cy(y3 + this.ry());
}
function cx(x3) {
  return x3 == null ? this.attr("cx") : this.attr("cx", x3);
}
function cy(y3) {
  return y3 == null ? this.attr("cy") : this.attr("cy", y3);
}
function width(width3) {
  return width3 == null ? this.rx() * 2 : this.rx(new SVGNumber_default(width3).divide(2));
}
function height(height3) {
  return height3 == null ? this.ry() * 2 : this.ry(new SVGNumber_default(height3).divide(2));
}

// node_modules/@svgdotjs/svg.js/src/elements/Shape.js
var Shape = class extends Element_default {
};
var Shape_default = Shape;
register(Shape, "Shape");

// node_modules/@svgdotjs/svg.js/src/elements/Circle.js
var Circle = class extends Shape_default {
  constructor(node) {
    super(nodeOrNew("circle", node), node);
  }
  radius(r) {
    return this.attr("r", r);
  }
  rx(rx2) {
    return this.attr("r", rx2);
  }
  ry(ry2) {
    return this.rx(ry2);
  }
  size(size2) {
    return this.radius(new SVGNumber_default(size2).divide(2));
  }
};
var Circle_default = Circle;
extend(Circle, {x, y, cx, cy, width, height});
registerMethods({
  Container: {
    circle: wrapWithAttrCheck(function(size2) {
      return this.put(new Circle()).size(size2).move(0, 0);
    })
  }
});
register(Circle, "Circle");

// node_modules/@svgdotjs/svg.js/src/elements/Container.js
var Container = class extends Element_default {
  flatten(parent) {
    this.each(function() {
      if (this instanceof Container)
        return this.flatten(parent).ungroup(parent);
      return this.toParent(parent);
    });
    this.node.firstElementChild || this.remove();
    return this;
  }
  ungroup(parent) {
    parent = parent || this.parent();
    this.each(function() {
      return this.toParent(parent);
    });
    this.remove();
    return this;
  }
};
var Container_default = Container;
register(Container, "Container");

// node_modules/@svgdotjs/svg.js/src/elements/Defs.js
var Defs = class extends Container_default {
  constructor(node) {
    super(nodeOrNew("defs", node), node);
  }
  flatten() {
    return this;
  }
  ungroup() {
    return this;
  }
};
var Defs_default = Defs;
register(Defs, "Defs");

// node_modules/@svgdotjs/svg.js/src/elements/Ellipse.js
var Ellipse = class extends Shape_default {
  constructor(node) {
    super(nodeOrNew("ellipse", node), node);
  }
  size(width3, height3) {
    var p = proportionalSize(this, width3, height3);
    return this.rx(new SVGNumber_default(p.width).divide(2)).ry(new SVGNumber_default(p.height).divide(2));
  }
};
var Ellipse_default = Ellipse;
extend(Ellipse, circled_exports);
registerMethods("Container", {
  ellipse: wrapWithAttrCheck(function(width3 = 0, height3 = width3) {
    return this.put(new Ellipse()).size(width3, height3).move(0, 0);
  })
});
register(Ellipse, "Ellipse");

// node_modules/@svgdotjs/svg.js/src/elements/Stop.js
var Stop = class extends Element_default {
  constructor(node) {
    super(nodeOrNew("stop", node), node);
  }
  update(o) {
    if (typeof o === "number" || o instanceof SVGNumber_default) {
      o = {
        offset: arguments[0],
        color: arguments[1],
        opacity: arguments[2]
      };
    }
    if (o.opacity != null)
      this.attr("stop-opacity", o.opacity);
    if (o.color != null)
      this.attr("stop-color", o.color);
    if (o.offset != null)
      this.attr("offset", new SVGNumber_default(o.offset));
    return this;
  }
};
var Stop_default = Stop;
register(Stop, "Stop");

// node_modules/@svgdotjs/svg.js/src/modules/core/gradiented.js
var gradiented_exports = {};
__export(gradiented_exports, {
  from: () => from,
  to: () => to
});
function from(x3, y3) {
  return (this._element || this).type === "radialGradient" ? this.attr({fx: new SVGNumber_default(x3), fy: new SVGNumber_default(y3)}) : this.attr({x1: new SVGNumber_default(x3), y1: new SVGNumber_default(y3)});
}
function to(x3, y3) {
  return (this._element || this).type === "radialGradient" ? this.attr({cx: new SVGNumber_default(x3), cy: new SVGNumber_default(y3)}) : this.attr({x2: new SVGNumber_default(x3), y2: new SVGNumber_default(y3)});
}

// node_modules/@svgdotjs/svg.js/src/elements/Gradient.js
var Gradient = class extends Container_default {
  constructor(type, attrs2) {
    super(nodeOrNew(type + "Gradient", typeof type === "string" ? null : type), attrs2);
  }
  stop(offset, color, opacity) {
    return this.put(new Stop_default()).update(offset, color, opacity);
  }
  update(block) {
    this.clear();
    if (typeof block === "function") {
      block.call(this, this);
    }
    return this;
  }
  url() {
    return "url(#" + this.id() + ")";
  }
  toString() {
    return this.url();
  }
  attr(a, b, c) {
    if (a === "transform")
      a = "gradientTransform";
    return super.attr(a, b, c);
  }
  targets() {
    return baseFind('svg [fill*="' + this.id() + '"]');
  }
  bbox() {
    return new Box_default();
  }
};
var Gradient_default = Gradient;
extend(Gradient, gradiented_exports);
registerMethods({
  Container: {
    gradient: wrapWithAttrCheck(function(type, block) {
      return this.defs().gradient(type, block);
    })
  },
  Defs: {
    gradient: wrapWithAttrCheck(function(type, block) {
      return this.put(new Gradient(type)).update(block);
    })
  }
});
register(Gradient, "Gradient");

// node_modules/@svgdotjs/svg.js/src/elements/Pattern.js
var Pattern = class extends Container_default {
  constructor(node) {
    super(nodeOrNew("pattern", node), node);
  }
  url() {
    return "url(#" + this.id() + ")";
  }
  update(block) {
    this.clear();
    if (typeof block === "function") {
      block.call(this, this);
    }
    return this;
  }
  toString() {
    return this.url();
  }
  attr(a, b, c) {
    if (a === "transform")
      a = "patternTransform";
    return super.attr(a, b, c);
  }
  targets() {
    return baseFind('svg [fill*="' + this.id() + '"]');
  }
  bbox() {
    return new Box_default();
  }
};
var Pattern_default = Pattern;
registerMethods({
  Container: {
    pattern(...args) {
      return this.defs().pattern(...args);
    }
  },
  Defs: {
    pattern: wrapWithAttrCheck(function(width3, height3, block) {
      return this.put(new Pattern()).update(block).attr({
        x: 0,
        y: 0,
        width: width3,
        height: height3,
        patternUnits: "userSpaceOnUse"
      });
    })
  }
});
register(Pattern, "Pattern");

// node_modules/@svgdotjs/svg.js/src/elements/Image.js
var Image = class extends Shape_default {
  constructor(node) {
    super(nodeOrNew("image", node), node);
  }
  load(url, callback) {
    if (!url)
      return this;
    var img = new globals.window.Image();
    on(img, "load", function(e) {
      var p = this.parent(Pattern_default);
      if (this.width() === 0 && this.height() === 0) {
        this.size(img.width, img.height);
      }
      if (p instanceof Pattern_default) {
        if (p.width() === 0 && p.height() === 0) {
          p.size(this.width(), this.height());
        }
      }
      if (typeof callback === "function") {
        callback.call(this, e);
      }
    }, this);
    on(img, "load error", function() {
      off(img);
    });
    return this.attr("href", img.src = url, xlink);
  }
};
var Image_default = Image;
registerAttrHook(function(attr2, val, _this) {
  if (attr2 === "fill" || attr2 === "stroke") {
    if (isImage.test(val)) {
      val = _this.root().defs().image(val);
    }
  }
  if (val instanceof Image) {
    val = _this.root().defs().pattern(0, 0, (pattern) => {
      pattern.add(val);
    });
  }
  return val;
});
registerMethods({
  Container: {
    image: wrapWithAttrCheck(function(source, callback) {
      return this.put(new Image()).size(0, 0).load(source, callback);
    })
  }
});
register(Image, "Image");

// node_modules/@svgdotjs/svg.js/src/types/PointArray.js
var PointArray = subClassArray("PointArray", SVGArray_default);
var PointArray_default = PointArray;
extend(PointArray, {
  toString() {
    for (var i = 0, il = this.length, array2 = []; i < il; i++) {
      array2.push(this[i].join(","));
    }
    return array2.join(" ");
  },
  toLine() {
    return {
      x1: this[0][0],
      y1: this[0][1],
      x2: this[1][0],
      y2: this[1][1]
    };
  },
  at(pos) {
    if (!this.destination)
      return this;
    for (var i = 0, il = this.length, array2 = []; i < il; i++) {
      array2.push([
        this[i][0] + (this.destination[i][0] - this[i][0]) * pos,
        this[i][1] + (this.destination[i][1] - this[i][1]) * pos
      ]);
    }
    return new PointArray(array2);
  },
  parse(array2 = [[0, 0]]) {
    var points = [];
    if (array2 instanceof Array) {
      if (array2[0] instanceof Array) {
        return array2;
      }
    } else {
      array2 = array2.trim().split(delimiter).map(parseFloat);
    }
    if (array2.length % 2 !== 0)
      array2.pop();
    for (var i = 0, len = array2.length; i < len; i = i + 2) {
      points.push([array2[i], array2[i + 1]]);
    }
    return points;
  },
  transform(m) {
    const points = [];
    for (let i = 0; i < this.length; i++) {
      const point2 = this[i];
      points.push([
        m.a * point2[0] + m.c * point2[1] + m.e,
        m.b * point2[0] + m.d * point2[1] + m.f
      ]);
    }
    return new PointArray(points);
  },
  move(x3, y3) {
    var box = this.bbox();
    x3 -= box.x;
    y3 -= box.y;
    if (!isNaN(x3) && !isNaN(y3)) {
      for (var i = this.length - 1; i >= 0; i--) {
        this[i] = [this[i][0] + x3, this[i][1] + y3];
      }
    }
    return this;
  },
  size(width3, height3) {
    var i;
    var box = this.bbox();
    for (i = this.length - 1; i >= 0; i--) {
      if (box.width)
        this[i][0] = (this[i][0] - box.x) * width3 / box.width + box.x;
      if (box.height)
        this[i][1] = (this[i][1] - box.y) * height3 / box.height + box.y;
    }
    return this;
  },
  bbox() {
    var maxX = -Infinity;
    var maxY = -Infinity;
    var minX = Infinity;
    var minY = Infinity;
    this.forEach(function(el) {
      maxX = Math.max(el[0], maxX);
      maxY = Math.max(el[1], maxY);
      minX = Math.min(el[0], minX);
      minY = Math.min(el[1], minY);
    });
    return {x: minX, y: minY, width: maxX - minX, height: maxY - minY};
  }
});

// node_modules/@svgdotjs/svg.js/src/modules/core/pointed.js
var pointed_exports = {};
__export(pointed_exports, {
  MorphArray: () => MorphArray,
  height: () => height2,
  width: () => width2,
  x: () => x2,
  y: () => y2
});
var MorphArray = PointArray_default;
function x2(x3) {
  return x3 == null ? this.bbox().x : this.move(x3, this.bbox().y);
}
function y2(y3) {
  return y3 == null ? this.bbox().y : this.move(this.bbox().x, y3);
}
function width2(width3) {
  const b = this.bbox();
  return width3 == null ? b.width : this.size(width3, b.height);
}
function height2(height3) {
  const b = this.bbox();
  return height3 == null ? b.height : this.size(b.width, height3);
}

// node_modules/@svgdotjs/svg.js/src/elements/Line.js
var Line = class extends Shape_default {
  constructor(node) {
    super(nodeOrNew("line", node), node);
  }
  array() {
    return new PointArray_default([
      [this.attr("x1"), this.attr("y1")],
      [this.attr("x2"), this.attr("y2")]
    ]);
  }
  plot(x1, y1, x22, y22) {
    if (x1 == null) {
      return this.array();
    } else if (typeof y1 !== "undefined") {
      x1 = {x1, y1, x2: x22, y2: y22};
    } else {
      x1 = new PointArray_default(x1).toLine();
    }
    return this.attr(x1);
  }
  move(x3, y3) {
    return this.attr(this.array().move(x3, y3).toLine());
  }
  size(width3, height3) {
    var p = proportionalSize(this, width3, height3);
    return this.attr(this.array().size(p.width, p.height).toLine());
  }
};
var Line_default = Line;
extend(Line, pointed_exports);
registerMethods({
  Container: {
    line: wrapWithAttrCheck(function(...args) {
      return Line.prototype.plot.apply(this.put(new Line()), args[0] != null ? args : [0, 0, 0, 0]);
    })
  }
});
register(Line, "Line");

// node_modules/@svgdotjs/svg.js/src/elements/Marker.js
var Marker = class extends Container_default {
  constructor(node) {
    super(nodeOrNew("marker", node), node);
  }
  width(width3) {
    return this.attr("markerWidth", width3);
  }
  height(height3) {
    return this.attr("markerHeight", height3);
  }
  ref(x3, y3) {
    return this.attr("refX", x3).attr("refY", y3);
  }
  update(block) {
    this.clear();
    if (typeof block === "function") {
      block.call(this, this);
    }
    return this;
  }
  toString() {
    return "url(#" + this.id() + ")";
  }
};
var Marker_default = Marker;
registerMethods({
  Container: {
    marker(...args) {
      return this.defs().marker(...args);
    }
  },
  Defs: {
    marker: wrapWithAttrCheck(function(width3, height3, block) {
      return this.put(new Marker()).size(width3, height3).ref(width3 / 2, height3 / 2).viewbox(0, 0, width3, height3).attr("orient", "auto").update(block);
    })
  },
  marker: {
    marker(marker, width3, height3, block) {
      var attr2 = ["marker"];
      if (marker !== "all")
        attr2.push(marker);
      attr2 = attr2.join("-");
      marker = arguments[1] instanceof Marker ? arguments[1] : this.defs().marker(width3, height3, block);
      return this.attr(attr2, marker);
    }
  }
});
register(Marker, "Marker");

// node_modules/@svgdotjs/svg.js/src/animation/Controller.js
function makeSetterGetter(k, f) {
  return function(v) {
    if (v == null)
      return this[v];
    this[k] = v;
    if (f)
      f.call(this);
    return this;
  };
}
var easing = {
  "-": function(pos) {
    return pos;
  },
  "<>": function(pos) {
    return -Math.cos(pos * Math.PI) / 2 + 0.5;
  },
  ">": function(pos) {
    return Math.sin(pos * Math.PI / 2);
  },
  "<": function(pos) {
    return -Math.cos(pos * Math.PI / 2) + 1;
  },
  bezier: function(x1, y1, x22, y22) {
    return function(t) {
      if (t < 0) {
        if (x1 > 0) {
          return y1 / x1 * t;
        } else if (x22 > 0) {
          return y22 / x22 * t;
        } else {
          return 0;
        }
      } else if (t > 1) {
        if (x22 < 1) {
          return (1 - y22) / (1 - x22) * t + (y22 - x22) / (1 - x22);
        } else if (x1 < 1) {
          return (1 - y1) / (1 - x1) * t + (y1 - x1) / (1 - x1);
        } else {
          return 1;
        }
      } else {
        return 3 * t * (1 - t) ** 2 * y1 + 3 * t ** 2 * (1 - t) * y22 + t ** 3;
      }
    };
  },
  steps: function(steps, stepPosition = "end") {
    stepPosition = stepPosition.split("-").reverse()[0];
    let jumps = steps;
    if (stepPosition === "none") {
      --jumps;
    } else if (stepPosition === "both") {
      ++jumps;
    }
    return (t, beforeFlag = false) => {
      let step = Math.floor(t * steps);
      const jumping = t * step % 1 === 0;
      if (stepPosition === "start" || stepPosition === "both") {
        ++step;
      }
      if (beforeFlag && jumping) {
        --step;
      }
      if (t >= 0 && step < 0) {
        step = 0;
      }
      if (t <= 1 && step > jumps) {
        step = jumps;
      }
      return step / jumps;
    };
  }
};
var Stepper = class {
  done() {
    return false;
  }
};
var Ease = class extends Stepper {
  constructor(fn) {
    super();
    this.ease = easing[fn || timeline.ease] || fn;
  }
  step(from2, to2, pos) {
    if (typeof from2 !== "number") {
      return pos < 1 ? from2 : to2;
    }
    return from2 + (to2 - from2) * this.ease(pos);
  }
};
var Controller = class extends Stepper {
  constructor(fn) {
    super();
    this.stepper = fn;
  }
  step(current, target, dt, c) {
    return this.stepper(current, target, dt, c);
  }
  done(c) {
    return c.done;
  }
};
function recalculate() {
  var duration = (this._duration || 500) / 1e3;
  var overshoot = this._overshoot || 0;
  var eps = 1e-10;
  var pi = Math.PI;
  var os = Math.log(overshoot / 100 + eps);
  var zeta = -os / Math.sqrt(pi * pi + os * os);
  var wn = 3.9 / (zeta * duration);
  this.d = 2 * zeta * wn;
  this.k = wn * wn;
}
var Spring = class extends Controller {
  constructor(duration, overshoot) {
    super();
    this.duration(duration || 500).overshoot(overshoot || 0);
  }
  step(current, target, dt, c) {
    if (typeof current === "string")
      return current;
    c.done = dt === Infinity;
    if (dt === Infinity)
      return target;
    if (dt === 0)
      return current;
    if (dt > 100)
      dt = 16;
    dt /= 1e3;
    var velocity = c.velocity || 0;
    var acceleration = -this.d * velocity - this.k * (current - target);
    var newPosition = current + velocity * dt + acceleration * dt * dt / 2;
    c.velocity = velocity + acceleration * dt;
    c.done = Math.abs(target - newPosition) + Math.abs(velocity) < 2e-3;
    return c.done ? target : newPosition;
  }
};
extend(Spring, {
  duration: makeSetterGetter("_duration", recalculate),
  overshoot: makeSetterGetter("_overshoot", recalculate)
});
var PID = class extends Controller {
  constructor(p, i, d, windup) {
    super();
    p = p == null ? 0.1 : p;
    i = i == null ? 0.01 : i;
    d = d == null ? 0 : d;
    windup = windup == null ? 1e3 : windup;
    this.p(p).i(i).d(d).windup(windup);
  }
  step(current, target, dt, c) {
    if (typeof current === "string")
      return current;
    c.done = dt === Infinity;
    if (dt === Infinity)
      return target;
    if (dt === 0)
      return current;
    var p = target - current;
    var i = (c.integral || 0) + p * dt;
    var d = (p - (c.error || 0)) / dt;
    var windup = this.windup;
    if (windup !== false) {
      i = Math.max(-windup, Math.min(i, windup));
    }
    c.error = p;
    c.integral = i;
    c.done = Math.abs(p) < 1e-3;
    return c.done ? target : current + (this.P * p + this.I * i + this.D * d);
  }
};
extend(PID, {
  windup: makeSetterGetter("windup"),
  p: makeSetterGetter("P"),
  i: makeSetterGetter("I"),
  d: makeSetterGetter("D")
});

// node_modules/@svgdotjs/svg.js/src/types/PathArray.js
var PathArray = subClassArray("PathArray", SVGArray_default);
var PathArray_default = PathArray;
function pathRegReplace(a, b, c, d) {
  return c + d.replace(dots, " .");
}
function arrayToString(a) {
  for (var i = 0, il = a.length, s = ""; i < il; i++) {
    s += a[i][0];
    if (a[i][1] != null) {
      s += a[i][1];
      if (a[i][2] != null) {
        s += " ";
        s += a[i][2];
        if (a[i][3] != null) {
          s += " ";
          s += a[i][3];
          s += " ";
          s += a[i][4];
          if (a[i][5] != null) {
            s += " ";
            s += a[i][5];
            s += " ";
            s += a[i][6];
            if (a[i][7] != null) {
              s += " ";
              s += a[i][7];
            }
          }
        }
      }
    }
  }
  return s + " ";
}
var pathHandlers = {
  M: function(c, p, p0) {
    p.x = p0.x = c[0];
    p.y = p0.y = c[1];
    return ["M", p.x, p.y];
  },
  L: function(c, p) {
    p.x = c[0];
    p.y = c[1];
    return ["L", c[0], c[1]];
  },
  H: function(c, p) {
    p.x = c[0];
    return ["H", c[0]];
  },
  V: function(c, p) {
    p.y = c[0];
    return ["V", c[0]];
  },
  C: function(c, p) {
    p.x = c[4];
    p.y = c[5];
    return ["C", c[0], c[1], c[2], c[3], c[4], c[5]];
  },
  S: function(c, p) {
    p.x = c[2];
    p.y = c[3];
    return ["S", c[0], c[1], c[2], c[3]];
  },
  Q: function(c, p) {
    p.x = c[2];
    p.y = c[3];
    return ["Q", c[0], c[1], c[2], c[3]];
  },
  T: function(c, p) {
    p.x = c[0];
    p.y = c[1];
    return ["T", c[0], c[1]];
  },
  Z: function(c, p, p0) {
    p.x = p0.x;
    p.y = p0.y;
    return ["Z"];
  },
  A: function(c, p) {
    p.x = c[5];
    p.y = c[6];
    return ["A", c[0], c[1], c[2], c[3], c[4], c[5], c[6]];
  }
};
var mlhvqtcsaz = "mlhvqtcsaz".split("");
for (var i = 0, il = mlhvqtcsaz.length; i < il; ++i) {
  pathHandlers[mlhvqtcsaz[i]] = function(i2) {
    return function(c, p, p0) {
      if (i2 === "H")
        c[0] = c[0] + p.x;
      else if (i2 === "V")
        c[0] = c[0] + p.y;
      else if (i2 === "A") {
        c[5] = c[5] + p.x;
        c[6] = c[6] + p.y;
      } else {
        for (var j = 0, jl = c.length; j < jl; ++j) {
          c[j] = c[j] + (j % 2 ? p.y : p.x);
        }
      }
      return pathHandlers[i2](c, p, p0);
    };
  }(mlhvqtcsaz[i].toUpperCase());
}
extend(PathArray, {
  toString() {
    return arrayToString(this);
  },
  move(x3, y3) {
    var box = this.bbox();
    x3 -= box.x;
    y3 -= box.y;
    if (!isNaN(x3) && !isNaN(y3)) {
      for (var l, i = this.length - 1; i >= 0; i--) {
        l = this[i][0];
        if (l === "M" || l === "L" || l === "T") {
          this[i][1] += x3;
          this[i][2] += y3;
        } else if (l === "H") {
          this[i][1] += x3;
        } else if (l === "V") {
          this[i][1] += y3;
        } else if (l === "C" || l === "S" || l === "Q") {
          this[i][1] += x3;
          this[i][2] += y3;
          this[i][3] += x3;
          this[i][4] += y3;
          if (l === "C") {
            this[i][5] += x3;
            this[i][6] += y3;
          }
        } else if (l === "A") {
          this[i][6] += x3;
          this[i][7] += y3;
        }
      }
    }
    return this;
  },
  size(width3, height3) {
    var box = this.bbox();
    var i, l;
    box.width = box.width === 0 ? 1 : box.width;
    box.height = box.height === 0 ? 1 : box.height;
    for (i = this.length - 1; i >= 0; i--) {
      l = this[i][0];
      if (l === "M" || l === "L" || l === "T") {
        this[i][1] = (this[i][1] - box.x) * width3 / box.width + box.x;
        this[i][2] = (this[i][2] - box.y) * height3 / box.height + box.y;
      } else if (l === "H") {
        this[i][1] = (this[i][1] - box.x) * width3 / box.width + box.x;
      } else if (l === "V") {
        this[i][1] = (this[i][1] - box.y) * height3 / box.height + box.y;
      } else if (l === "C" || l === "S" || l === "Q") {
        this[i][1] = (this[i][1] - box.x) * width3 / box.width + box.x;
        this[i][2] = (this[i][2] - box.y) * height3 / box.height + box.y;
        this[i][3] = (this[i][3] - box.x) * width3 / box.width + box.x;
        this[i][4] = (this[i][4] - box.y) * height3 / box.height + box.y;
        if (l === "C") {
          this[i][5] = (this[i][5] - box.x) * width3 / box.width + box.x;
          this[i][6] = (this[i][6] - box.y) * height3 / box.height + box.y;
        }
      } else if (l === "A") {
        this[i][1] = this[i][1] * width3 / box.width;
        this[i][2] = this[i][2] * height3 / box.height;
        this[i][6] = (this[i][6] - box.x) * width3 / box.width + box.x;
        this[i][7] = (this[i][7] - box.y) * height3 / box.height + box.y;
      }
    }
    return this;
  },
  equalCommands(pathArray) {
    var i, il, equalCommands;
    pathArray = new PathArray(pathArray);
    equalCommands = this.length === pathArray.length;
    for (i = 0, il = this.length; equalCommands && i < il; i++) {
      equalCommands = this[i][0] === pathArray[i][0];
    }
    return equalCommands;
  },
  morph(pathArray) {
    pathArray = new PathArray(pathArray);
    if (this.equalCommands(pathArray)) {
      this.destination = pathArray;
    } else {
      this.destination = null;
    }
    return this;
  },
  at(pos) {
    if (!this.destination)
      return this;
    var sourceArray = this;
    var destinationArray = this.destination.value;
    var array2 = [];
    var pathArray = new PathArray();
    var i, il, j, jl;
    for (i = 0, il = sourceArray.length; i < il; i++) {
      array2[i] = [sourceArray[i][0]];
      for (j = 1, jl = sourceArray[i].length; j < jl; j++) {
        array2[i][j] = sourceArray[i][j] + (destinationArray[i][j] - sourceArray[i][j]) * pos;
      }
      if (array2[i][0] === "A") {
        array2[i][4] = +(array2[i][4] !== 0);
        array2[i][5] = +(array2[i][5] !== 0);
      }
    }
    pathArray.value = array2;
    return pathArray;
  },
  parse(array2 = [["M", 0, 0]]) {
    if (array2 instanceof PathArray)
      return array2;
    var s;
    var paramCnt = {M: 2, L: 2, H: 1, V: 1, C: 6, S: 4, Q: 4, T: 2, A: 7, Z: 0};
    if (typeof array2 === "string") {
      array2 = array2.replace(numbersWithDots, pathRegReplace).replace(pathLetters, " $& ").replace(hyphen, "$1 -").trim().split(delimiter);
    } else {
      array2 = array2.reduce(function(prev2, curr) {
        return [].concat.call(prev2, curr);
      }, []);
    }
    var result = [];
    var p = new Point_default();
    var p0 = new Point_default();
    var index = 0;
    var len = array2.length;
    do {
      if (isPathLetter.test(array2[index])) {
        s = array2[index];
        ++index;
      } else if (s === "M") {
        s = "L";
      } else if (s === "m") {
        s = "l";
      }
      result.push(pathHandlers[s].call(null, array2.slice(index, index = index + paramCnt[s.toUpperCase()]).map(parseFloat), p, p0));
    } while (len > index);
    return result;
  },
  bbox() {
    parser().path.setAttribute("d", this.toString());
    return parser.nodes.path.getBBox();
  }
});

// node_modules/@svgdotjs/svg.js/src/animation/Morphable.js
var Morphable = class {
  constructor(stepper) {
    this._stepper = stepper || new Ease("-");
    this._from = null;
    this._to = null;
    this._type = null;
    this._context = null;
    this._morphObj = null;
  }
  from(val) {
    if (val == null) {
      return this._from;
    }
    this._from = this._set(val);
    return this;
  }
  to(val) {
    if (val == null) {
      return this._to;
    }
    this._to = this._set(val);
    return this;
  }
  type(type) {
    if (type == null) {
      return this._type;
    }
    this._type = type;
    return this;
  }
  _set(value) {
    if (!this._type) {
      var type = typeof value;
      if (type === "number") {
        this.type(SVGNumber_default);
      } else if (type === "string") {
        if (Color_default.isColor(value)) {
          this.type(Color_default);
        } else if (delimiter.test(value)) {
          this.type(pathLetters.test(value) ? PathArray_default : SVGArray_default);
        } else if (numberAndUnit.test(value)) {
          this.type(SVGNumber_default);
        } else {
          this.type(NonMorphable);
        }
      } else if (morphableTypes.indexOf(value.constructor) > -1) {
        this.type(value.constructor);
      } else if (Array.isArray(value)) {
        this.type(SVGArray_default);
      } else if (type === "object") {
        this.type(ObjectBag);
      } else {
        this.type(NonMorphable);
      }
    }
    var result = new this._type(value);
    if (this._type === Color_default) {
      result = this._to ? result[this._to[4]]() : this._from ? result[this._from[4]]() : result;
    }
    result = result.toArray();
    this._morphObj = this._morphObj || new this._type();
    this._context = this._context || Array.apply(null, Array(result.length)).map(Object).map(function(o) {
      o.done = true;
      return o;
    });
    return result;
  }
  stepper(stepper) {
    if (stepper == null)
      return this._stepper;
    this._stepper = stepper;
    return this;
  }
  done() {
    var complete = this._context.map(this._stepper.done).reduce(function(last, curr) {
      return last && curr;
    }, true);
    return complete;
  }
  at(pos) {
    var _this = this;
    return this._morphObj.fromArray(this._from.map(function(i, index) {
      return _this._stepper.step(i, _this._to[index], pos, _this._context[index], _this._context);
    }));
  }
};
var Morphable_default = Morphable;
var NonMorphable = class {
  constructor(...args) {
    this.init(...args);
  }
  init(val) {
    val = Array.isArray(val) ? val[0] : val;
    this.value = val;
    return this;
  }
  valueOf() {
    return this.value;
  }
  toArray() {
    return [this.value];
  }
};
var TransformBag = class {
  constructor(...args) {
    this.init(...args);
  }
  init(obj) {
    if (Array.isArray(obj)) {
      obj = {
        scaleX: obj[0],
        scaleY: obj[1],
        shear: obj[2],
        rotate: obj[3],
        translateX: obj[4],
        translateY: obj[5],
        originX: obj[6],
        originY: obj[7]
      };
    }
    Object.assign(this, TransformBag.defaults, obj);
    return this;
  }
  toArray() {
    var v = this;
    return [
      v.scaleX,
      v.scaleY,
      v.shear,
      v.rotate,
      v.translateX,
      v.translateY,
      v.originX,
      v.originY
    ];
  }
};
TransformBag.defaults = {
  scaleX: 1,
  scaleY: 1,
  shear: 0,
  rotate: 0,
  translateX: 0,
  translateY: 0,
  originX: 0,
  originY: 0
};
var ObjectBag = class {
  constructor(...args) {
    this.init(...args);
  }
  init(objOrArr) {
    this.values = [];
    if (Array.isArray(objOrArr)) {
      this.values = objOrArr;
      return;
    }
    objOrArr = objOrArr || {};
    var entries = [];
    for (const i in objOrArr) {
      entries.push([i, objOrArr[i]]);
    }
    entries.sort((a, b) => {
      return a[0] - b[0];
    });
    this.values = entries.reduce((last, curr) => last.concat(curr), []);
    return this;
  }
  valueOf() {
    var obj = {};
    var arr = this.values;
    for (var i = 0, len = arr.length; i < len; i += 2) {
      obj[arr[i]] = arr[i + 1];
    }
    return obj;
  }
  toArray() {
    return this.values;
  }
};
var morphableTypes = [
  NonMorphable,
  TransformBag,
  ObjectBag
];
function registerMorphableType(type = []) {
  morphableTypes.push(...[].concat(type));
}
function makeMorphable() {
  extend(morphableTypes, {
    to(val) {
      return new Morphable().type(this.constructor).from(this.valueOf()).to(val);
    },
    fromArray(arr) {
      this.init(arr);
      return this;
    }
  });
}

// node_modules/@svgdotjs/svg.js/src/elements/Path.js
var Path = class extends Shape_default {
  constructor(node) {
    super(nodeOrNew("path", node), node);
  }
  array() {
    return this._array || (this._array = new PathArray_default(this.attr("d")));
  }
  plot(d) {
    return d == null ? this.array() : this.clear().attr("d", typeof d === "string" ? d : this._array = new PathArray_default(d));
  }
  clear() {
    delete this._array;
    return this;
  }
  move(x3, y3) {
    return this.attr("d", this.array().move(x3, y3));
  }
  x(x3) {
    return x3 == null ? this.bbox().x : this.move(x3, this.bbox().y);
  }
  y(y3) {
    return y3 == null ? this.bbox().y : this.move(this.bbox().x, y3);
  }
  size(width3, height3) {
    var p = proportionalSize(this, width3, height3);
    return this.attr("d", this.array().size(p.width, p.height));
  }
  width(width3) {
    return width3 == null ? this.bbox().width : this.size(width3, this.bbox().height);
  }
  height(height3) {
    return height3 == null ? this.bbox().height : this.size(this.bbox().width, height3);
  }
  targets() {
    return baseFind('svg textpath [href*="' + this.id() + '"]');
  }
};
var Path_default = Path;
Path.prototype.MorphArray = PathArray_default;
registerMethods({
  Container: {
    path: wrapWithAttrCheck(function(d) {
      return this.put(new Path()).plot(d || new PathArray_default());
    })
  }
});
register(Path, "Path");

// node_modules/@svgdotjs/svg.js/src/modules/core/poly.js
var poly_exports = {};
__export(poly_exports, {
  array: () => array,
  clear: () => clear,
  move: () => move,
  plot: () => plot,
  size: () => size
});
function array() {
  return this._array || (this._array = new PointArray_default(this.attr("points")));
}
function plot(p) {
  return p == null ? this.array() : this.clear().attr("points", typeof p === "string" ? p : this._array = new PointArray_default(p));
}
function clear() {
  delete this._array;
  return this;
}
function move(x3, y3) {
  return this.attr("points", this.array().move(x3, y3));
}
function size(width3, height3) {
  const p = proportionalSize(this, width3, height3);
  return this.attr("points", this.array().size(p.width, p.height));
}

// node_modules/@svgdotjs/svg.js/src/elements/Polygon.js
var Polygon = class extends Shape_default {
  constructor(node) {
    super(nodeOrNew("polygon", node), node);
  }
};
var Polygon_default = Polygon;
registerMethods({
  Container: {
    polygon: wrapWithAttrCheck(function(p) {
      return this.put(new Polygon()).plot(p || new PointArray_default());
    })
  }
});
extend(Polygon, pointed_exports);
extend(Polygon, poly_exports);
register(Polygon, "Polygon");

// node_modules/@svgdotjs/svg.js/src/elements/Polyline.js
var Polyline = class extends Shape_default {
  constructor(node) {
    super(nodeOrNew("polyline", node), node);
  }
};
var Polyline_default = Polyline;
registerMethods({
  Container: {
    polyline: wrapWithAttrCheck(function(p) {
      return this.put(new Polyline()).plot(p || new PointArray_default());
    })
  }
});
extend(Polyline, pointed_exports);
extend(Polyline, poly_exports);
register(Polyline, "Polyline");

// node_modules/@svgdotjs/svg.js/src/elements/Rect.js
var Rect = class extends Shape_default {
  constructor(node) {
    super(nodeOrNew("rect", node), node);
  }
};
var Rect_default = Rect;
extend(Rect, {rx, ry});
registerMethods({
  Container: {
    rect: wrapWithAttrCheck(function(width3, height3) {
      return this.put(new Rect()).size(width3, height3);
    })
  }
});
register(Rect, "Rect");

// node_modules/@svgdotjs/svg.js/src/animation/Queue.js
var Queue = class {
  constructor() {
    this._first = null;
    this._last = null;
  }
  push(value) {
    var item = value.next ? value : {value, next: null, prev: null};
    if (this._last) {
      item.prev = this._last;
      this._last.next = item;
      this._last = item;
    } else {
      this._last = item;
      this._first = item;
    }
    return item;
  }
  shift() {
    var remove = this._first;
    if (!remove)
      return null;
    this._first = remove.next;
    if (this._first)
      this._first.prev = null;
    this._last = this._first ? this._last : null;
    return remove.value;
  }
  first() {
    return this._first && this._first.value;
  }
  last() {
    return this._last && this._last.value;
  }
  remove(item) {
    if (item.prev)
      item.prev.next = item.next;
    if (item.next)
      item.next.prev = item.prev;
    if (item === this._last)
      this._last = item.prev;
    if (item === this._first)
      this._first = item.next;
    item.prev = null;
    item.next = null;
  }
};
var Queue_default = Queue;

// node_modules/@svgdotjs/svg.js/src/animation/Animator.js
var Animator = {
  nextDraw: null,
  frames: new Queue_default(),
  timeouts: new Queue_default(),
  immediates: new Queue_default(),
  timer: () => globals.window.performance || globals.window.Date,
  transforms: [],
  frame(fn) {
    var node = Animator.frames.push({run: fn});
    if (Animator.nextDraw === null) {
      Animator.nextDraw = globals.window.requestAnimationFrame(Animator._draw);
    }
    return node;
  },
  timeout(fn, delay) {
    delay = delay || 0;
    var time = Animator.timer().now() + delay;
    var node = Animator.timeouts.push({run: fn, time});
    if (Animator.nextDraw === null) {
      Animator.nextDraw = globals.window.requestAnimationFrame(Animator._draw);
    }
    return node;
  },
  immediate(fn) {
    var node = Animator.immediates.push(fn);
    if (Animator.nextDraw === null) {
      Animator.nextDraw = globals.window.requestAnimationFrame(Animator._draw);
    }
    return node;
  },
  cancelFrame(node) {
    node != null && Animator.frames.remove(node);
  },
  clearTimeout(node) {
    node != null && Animator.timeouts.remove(node);
  },
  cancelImmediate(node) {
    node != null && Animator.immediates.remove(node);
  },
  _draw(now) {
    var nextTimeout = null;
    var lastTimeout = Animator.timeouts.last();
    while (nextTimeout = Animator.timeouts.shift()) {
      if (now >= nextTimeout.time) {
        nextTimeout.run();
      } else {
        Animator.timeouts.push(nextTimeout);
      }
      if (nextTimeout === lastTimeout)
        break;
    }
    var nextFrame = null;
    var lastFrame = Animator.frames.last();
    while (nextFrame !== lastFrame && (nextFrame = Animator.frames.shift())) {
      nextFrame.run(now);
    }
    var nextImmediate = null;
    while (nextImmediate = Animator.immediates.shift()) {
      nextImmediate();
    }
    Animator.nextDraw = Animator.timeouts.first() || Animator.frames.first() ? globals.window.requestAnimationFrame(Animator._draw) : null;
  }
};
var Animator_default = Animator;

// node_modules/@svgdotjs/svg.js/src/animation/Timeline.js
var makeSchedule = function(runnerInfo) {
  var start = runnerInfo.start;
  var duration = runnerInfo.runner.duration();
  var end = start + duration;
  return {start, duration, end, runner: runnerInfo.runner};
};
var defaultSource = function() {
  const w = globals.window;
  return (w.performance || w.Date).now();
};
var Timeline = class extends EventTarget_default {
  constructor(timeSource = defaultSource) {
    super();
    this._timeSource = timeSource;
    this._startTime = 0;
    this._speed = 1;
    this._persist = 0;
    this._nextFrame = null;
    this._paused = true;
    this._runners = [];
    this._runnerIds = [];
    this._lastRunnerId = -1;
    this._time = 0;
    this._lastSourceTime = 0;
    this._lastStepTime = 0;
    this._step = this._stepFn.bind(this, false);
    this._stepImmediate = this._stepFn.bind(this, true);
  }
  schedule(runner, delay, when) {
    if (runner == null) {
      return this._runners.map(makeSchedule);
    }
    var absoluteStartTime = 0;
    var endTime = this.getEndTime();
    delay = delay || 0;
    if (when == null || when === "last" || when === "after") {
      absoluteStartTime = endTime;
    } else if (when === "absolute" || when === "start") {
      absoluteStartTime = delay;
      delay = 0;
    } else if (when === "now") {
      absoluteStartTime = this._time;
    } else if (when === "relative") {
      const runnerInfo2 = this._runners[runner.id];
      if (runnerInfo2) {
        absoluteStartTime = runnerInfo2.start + delay;
        delay = 0;
      }
    } else {
      throw new Error('Invalid value for the "when" parameter');
    }
    runner.unschedule();
    runner.timeline(this);
    const persist = runner.persist();
    const runnerInfo = {
      persist: persist === null ? this._persist : persist,
      start: absoluteStartTime + delay,
      runner
    };
    this._lastRunnerId = runner.id;
    this._runners.push(runnerInfo);
    this._runners.sort((a, b) => a.start - b.start);
    this._runnerIds = this._runners.map((info) => info.runner.id);
    this.updateTime()._continue();
    return this;
  }
  unschedule(runner) {
    var index = this._runnerIds.indexOf(runner.id);
    if (index < 0)
      return this;
    this._runners.splice(index, 1);
    this._runnerIds.splice(index, 1);
    runner.timeline(null);
    return this;
  }
  getEndTime() {
    var lastRunnerInfo = this._runners[this._runnerIds.indexOf(this._lastRunnerId)];
    var lastDuration = lastRunnerInfo ? lastRunnerInfo.runner.duration() : 0;
    var lastStartTime = lastRunnerInfo ? lastRunnerInfo.start : 0;
    return lastStartTime + lastDuration;
  }
  getEndTimeOfTimeline() {
    let lastEndTime = 0;
    for (var i = 0; i < this._runners.length; i++) {
      const runnerInfo = this._runners[i];
      var duration = runnerInfo ? runnerInfo.runner.duration() : 0;
      var startTime = runnerInfo ? runnerInfo.start : 0;
      const endTime = startTime + duration;
      if (endTime > lastEndTime) {
        lastEndTime = endTime;
      }
    }
    return lastEndTime;
  }
  updateTime() {
    if (!this.active()) {
      this._lastSourceTime = this._timeSource();
    }
    return this;
  }
  play() {
    this._paused = false;
    return this.updateTime()._continue();
  }
  pause() {
    this._paused = true;
    return this._continue();
  }
  stop() {
    this.time(0);
    return this.pause();
  }
  finish() {
    this.time(this.getEndTimeOfTimeline() + 1);
    return this.pause();
  }
  speed(speed) {
    if (speed == null)
      return this._speed;
    this._speed = speed;
    return this;
  }
  reverse(yes) {
    var currentSpeed = this.speed();
    if (yes == null)
      return this.speed(-currentSpeed);
    var positive = Math.abs(currentSpeed);
    return this.speed(yes ? positive : -positive);
  }
  seek(dt) {
    return this.time(this._time + dt);
  }
  time(time) {
    if (time == null)
      return this._time;
    this._time = time;
    return this._continue(true);
  }
  persist(dtOrForever) {
    if (dtOrForever == null)
      return this._persist;
    this._persist = dtOrForever;
    return this;
  }
  source(fn) {
    if (fn == null)
      return this._timeSource;
    this._timeSource = fn;
    return this;
  }
  _stepFn(immediateStep = false) {
    var time = this._timeSource();
    var dtSource = time - this._lastSourceTime;
    if (immediateStep)
      dtSource = 0;
    var dtTime = this._speed * dtSource + (this._time - this._lastStepTime);
    this._lastSourceTime = time;
    if (!immediateStep) {
      this._time += dtTime;
      this._time = this._time < 0 ? 0 : this._time;
    }
    this._lastStepTime = this._time;
    this.fire("time", this._time);
    for (var k = this._runners.length; k--; ) {
      const runnerInfo = this._runners[k];
      const runner = runnerInfo.runner;
      const dtToStart = this._time - runnerInfo.start;
      if (dtToStart <= 0) {
        runner.reset();
      }
    }
    var runnersLeft = false;
    for (var i = 0, len = this._runners.length; i < len; i++) {
      const runnerInfo = this._runners[i];
      const runner = runnerInfo.runner;
      let dt = dtTime;
      const dtToStart = this._time - runnerInfo.start;
      if (dtToStart <= 0) {
        runnersLeft = true;
        continue;
      } else if (dtToStart < dt) {
        dt = dtToStart;
      }
      if (!runner.active())
        continue;
      var finished = runner.step(dt).done;
      if (!finished) {
        runnersLeft = true;
      } else if (runnerInfo.persist !== true) {
        var endTime = runner.duration() - runner.time() + this._time;
        if (endTime + runnerInfo.persist < this._time) {
          runner.unschedule();
          --i;
          --len;
        }
      }
    }
    if (runnersLeft && !(this._speed < 0 && this._time === 0) || this._runnerIds.length && this._speed < 0 && this._time > 0) {
      this._continue();
    } else {
      this.pause();
      this.fire("finished");
    }
    return this;
  }
  _continue(immediateStep = false) {
    Animator_default.cancelFrame(this._nextFrame);
    this._nextFrame = null;
    if (immediateStep)
      return this._stepImmediate();
    if (this._paused)
      return this;
    this._nextFrame = Animator_default.frame(this._step);
    return this;
  }
  active() {
    return !!this._nextFrame;
  }
};
var Timeline_default = Timeline;
registerMethods({
  Element: {
    timeline: function(timeline2) {
      if (timeline2 == null) {
        this._timeline = this._timeline || new Timeline();
        return this._timeline;
      } else {
        this._timeline = timeline2;
        return this;
      }
    }
  }
});

// node_modules/@svgdotjs/svg.js/src/animation/Runner.js
var Runner = class extends EventTarget_default {
  constructor(options) {
    super();
    this.id = Runner.id++;
    options = options == null ? timeline.duration : options;
    options = typeof options === "function" ? new Controller(options) : options;
    this._element = null;
    this._timeline = null;
    this.done = false;
    this._queue = [];
    this._duration = typeof options === "number" && options;
    this._isDeclarative = options instanceof Controller;
    this._stepper = this._isDeclarative ? options : new Ease();
    this._history = {};
    this.enabled = true;
    this._time = 0;
    this._lastTime = 0;
    this._reseted = true;
    this.transforms = new Matrix_default();
    this.transformId = 1;
    this._haveReversed = false;
    this._reverse = false;
    this._loopsDone = 0;
    this._swing = false;
    this._wait = 0;
    this._times = 1;
    this._frameId = null;
    this._persist = this._isDeclarative ? true : null;
  }
  element(element) {
    if (element == null)
      return this._element;
    this._element = element;
    element._prepareRunner();
    return this;
  }
  timeline(timeline2) {
    if (typeof timeline2 === "undefined")
      return this._timeline;
    this._timeline = timeline2;
    return this;
  }
  animate(duration, delay, when) {
    var o = Runner.sanitise(duration, delay, when);
    var runner = new Runner(o.duration);
    if (this._timeline)
      runner.timeline(this._timeline);
    if (this._element)
      runner.element(this._element);
    return runner.loop(o).schedule(o.delay, o.when);
  }
  schedule(timeline2, delay, when) {
    if (!(timeline2 instanceof Timeline_default)) {
      when = delay;
      delay = timeline2;
      timeline2 = this.timeline();
    }
    if (!timeline2) {
      throw Error("Runner cannot be scheduled without timeline");
    }
    timeline2.schedule(this, delay, when);
    return this;
  }
  unschedule() {
    var timeline2 = this.timeline();
    timeline2 && timeline2.unschedule(this);
    return this;
  }
  loop(times, swing, wait) {
    if (typeof times === "object") {
      swing = times.swing;
      wait = times.wait;
      times = times.times;
    }
    this._times = times || Infinity;
    this._swing = swing || false;
    this._wait = wait || 0;
    if (this._times === true) {
      this._times = Infinity;
    }
    return this;
  }
  delay(delay) {
    return this.animate(0, delay);
  }
  queue(initFn, runFn, retargetFn, isTransform) {
    this._queue.push({
      initialiser: initFn || noop,
      runner: runFn || noop,
      retarget: retargetFn,
      isTransform,
      initialised: false,
      finished: false
    });
    var timeline2 = this.timeline();
    timeline2 && this.timeline()._continue();
    return this;
  }
  during(fn) {
    return this.queue(null, fn);
  }
  after(fn) {
    return this.on("finished", fn);
  }
  time(time) {
    if (time == null) {
      return this._time;
    }
    const dt = time - this._time;
    this.step(dt);
    return this;
  }
  duration() {
    return this._times * (this._wait + this._duration) - this._wait;
  }
  loops(p) {
    var loopDuration = this._duration + this._wait;
    if (p == null) {
      var loopsDone = Math.floor(this._time / loopDuration);
      var relativeTime = this._time - loopsDone * loopDuration;
      var position2 = relativeTime / this._duration;
      return Math.min(loopsDone + position2, this._times);
    }
    var whole = Math.floor(p);
    var partial = p % 1;
    var time = loopDuration * whole + this._duration * partial;
    return this.time(time);
  }
  persist(dtOrForever) {
    if (dtOrForever == null)
      return this._persist;
    this._persist = dtOrForever;
    return this;
  }
  position(p) {
    var x3 = this._time;
    var d = this._duration;
    var w = this._wait;
    var t = this._times;
    var s = this._swing;
    var r = this._reverse;
    var position2;
    if (p == null) {
      const f = function(x4) {
        var swinging = s * Math.floor(x4 % (2 * (w + d)) / (w + d));
        var backwards = swinging && !r || !swinging && r;
        var uncliped = Math.pow(-1, backwards) * (x4 % (w + d)) / d + backwards;
        var clipped = Math.max(Math.min(uncliped, 1), 0);
        return clipped;
      };
      var endTime = t * (w + d) - w;
      position2 = x3 <= 0 ? Math.round(f(1e-5)) : x3 < endTime ? f(x3) : Math.round(f(endTime - 1e-5));
      return position2;
    }
    var loopsDone = Math.floor(this.loops());
    var swingForward = s && loopsDone % 2 === 0;
    var forwards = swingForward && !r || r && swingForward;
    position2 = loopsDone + (forwards ? p : 1 - p);
    return this.loops(position2);
  }
  progress(p) {
    if (p == null) {
      return Math.min(1, this._time / this.duration());
    }
    return this.time(p * this.duration());
  }
  step(dt) {
    if (!this.enabled)
      return this;
    dt = dt == null ? 16 : dt;
    this._time += dt;
    var position2 = this.position();
    var running = this._lastPosition !== position2 && this._time >= 0;
    this._lastPosition = position2;
    var duration = this.duration();
    var justStarted = this._lastTime <= 0 && this._time > 0;
    var justFinished = this._lastTime < duration && this._time >= duration;
    this._lastTime = this._time;
    if (justStarted) {
      this.fire("start", this);
    }
    var declarative = this._isDeclarative;
    this.done = !declarative && !justFinished && this._time >= duration;
    this._reseted = false;
    if (running || declarative) {
      this._initialise(running);
      this.transforms = new Matrix_default();
      var converged = this._run(declarative ? dt : position2);
      this.fire("step", this);
    }
    this.done = this.done || converged && declarative;
    if (justFinished) {
      this.fire("finished", this);
    }
    return this;
  }
  reset() {
    if (this._reseted)
      return this;
    this.time(0);
    this._reseted = true;
    return this;
  }
  finish() {
    return this.step(Infinity);
  }
  reverse(reverse) {
    this._reverse = reverse == null ? !this._reverse : reverse;
    return this;
  }
  ease(fn) {
    this._stepper = new Ease(fn);
    return this;
  }
  active(enabled) {
    if (enabled == null)
      return this.enabled;
    this.enabled = enabled;
    return this;
  }
  _rememberMorpher(method, morpher) {
    this._history[method] = {
      morpher,
      caller: this._queue[this._queue.length - 1]
    };
    if (this._isDeclarative) {
      var timeline2 = this.timeline();
      timeline2 && timeline2.play();
    }
  }
  _tryRetarget(method, target, extra) {
    if (this._history[method]) {
      if (!this._history[method].caller.initialised) {
        const index = this._queue.indexOf(this._history[method].caller);
        this._queue.splice(index, 1);
        return false;
      }
      if (this._history[method].caller.retarget) {
        this._history[method].caller.retarget(target, extra);
      } else {
        this._history[method].morpher.to(target);
      }
      this._history[method].caller.finished = false;
      var timeline2 = this.timeline();
      timeline2 && timeline2.play();
      return true;
    }
    return false;
  }
  _initialise(running) {
    if (!running && !this._isDeclarative)
      return;
    for (var i = 0, len = this._queue.length; i < len; ++i) {
      var current = this._queue[i];
      var needsIt = this._isDeclarative || !current.initialised && running;
      running = !current.finished;
      if (needsIt && running) {
        current.initialiser.call(this);
        current.initialised = true;
      }
    }
  }
  _run(positionOrDt) {
    var allfinished = true;
    for (var i = 0, len = this._queue.length; i < len; ++i) {
      var current = this._queue[i];
      var converged = current.runner.call(this, positionOrDt);
      current.finished = current.finished || converged === true;
      allfinished = allfinished && current.finished;
    }
    return allfinished;
  }
  addTransform(transform2, index) {
    this.transforms.lmultiplyO(transform2);
    return this;
  }
  clearTransform() {
    this.transforms = new Matrix_default();
    return this;
  }
  clearTransformsFromQueue() {
    if (!this.done || !this._timeline || !this._timeline._runnerIds.includes(this.id)) {
      this._queue = this._queue.filter((item) => {
        return !item.isTransform;
      });
    }
  }
  static sanitise(duration, delay, when) {
    var times = 1;
    var swing = false;
    var wait = 0;
    duration = duration || timeline.duration;
    delay = delay || timeline.delay;
    when = when || "last";
    if (typeof duration === "object" && !(duration instanceof Stepper)) {
      delay = duration.delay || delay;
      when = duration.when || when;
      swing = duration.swing || swing;
      times = duration.times || times;
      wait = duration.wait || wait;
      duration = duration.duration || timeline.duration;
    }
    return {
      duration,
      delay,
      swing,
      times,
      wait,
      when
    };
  }
};
var Runner_default = Runner;
Runner.id = 0;
var FakeRunner = class {
  constructor(transforms2 = new Matrix_default(), id = -1, done = true) {
    this.transforms = transforms2;
    this.id = id;
    this.done = done;
  }
  clearTransformsFromQueue() {
  }
};
extend([Runner, FakeRunner], {
  mergeWith(runner) {
    return new FakeRunner(runner.transforms.lmultiply(this.transforms), runner.id);
  }
});
var lmultiply = (last, curr) => last.lmultiplyO(curr);
var getRunnerTransform = (runner) => runner.transforms;
function mergeTransforms() {
  const runners = this._transformationRunners.runners;
  const netTransform = runners.map(getRunnerTransform).reduce(lmultiply, new Matrix_default());
  this.transform(netTransform);
  this._transformationRunners.merge();
  if (this._transformationRunners.length() === 1) {
    this._frameId = null;
  }
}
var RunnerArray = class {
  constructor() {
    this.runners = [];
    this.ids = [];
  }
  add(runner) {
    if (this.runners.includes(runner))
      return;
    const id = runner.id + 1;
    this.runners.push(runner);
    this.ids.push(id);
    return this;
  }
  getByID(id) {
    return this.runners[this.ids.indexOf(id + 1)];
  }
  remove(id) {
    const index = this.ids.indexOf(id + 1);
    this.ids.splice(index, 1);
    this.runners.splice(index, 1);
    return this;
  }
  merge() {
    let lastRunner = null;
    this.runners.forEach((runner, i) => {
      const condition = lastRunner && runner.done && lastRunner.done && (!runner._timeline || !runner._timeline._runnerIds.includes(runner.id)) && (!lastRunner._timeline || !lastRunner._timeline._runnerIds.includes(lastRunner.id));
      if (condition) {
        this.remove(runner.id);
        this.edit(lastRunner.id, runner.mergeWith(lastRunner));
      }
      lastRunner = runner;
    });
    return this;
  }
  edit(id, newRunner) {
    const index = this.ids.indexOf(id + 1);
    this.ids.splice(index, 1, id + 1);
    this.runners.splice(index, 1, newRunner);
    return this;
  }
  length() {
    return this.ids.length;
  }
  clearBefore(id) {
    const deleteCnt = this.ids.indexOf(id + 1) || 1;
    this.ids.splice(0, deleteCnt, 0);
    this.runners.splice(0, deleteCnt, new FakeRunner()).forEach((r) => r.clearTransformsFromQueue());
    return this;
  }
};
registerMethods({
  Element: {
    animate(duration, delay, when) {
      var o = Runner.sanitise(duration, delay, when);
      var timeline2 = this.timeline();
      return new Runner(o.duration).loop(o).element(this).timeline(timeline2.play()).schedule(o.delay, o.when);
    },
    delay(by, when) {
      return this.animate(0, by, when);
    },
    _clearTransformRunnersBefore(currentRunner) {
      this._transformationRunners.clearBefore(currentRunner.id);
    },
    _currentTransform(current) {
      return this._transformationRunners.runners.filter((runner) => runner.id <= current.id).map(getRunnerTransform).reduce(lmultiply, new Matrix_default());
    },
    _addRunner(runner) {
      this._transformationRunners.add(runner);
      Animator_default.cancelImmediate(this._frameId);
      this._frameId = Animator_default.immediate(mergeTransforms.bind(this));
    },
    _prepareRunner() {
      if (this._frameId == null) {
        this._transformationRunners = new RunnerArray().add(new FakeRunner(new Matrix_default(this)));
      }
    }
  }
});
extend(Runner, {
  attr(a, v) {
    return this.styleAttr("attr", a, v);
  },
  css(s, v) {
    return this.styleAttr("css", s, v);
  },
  styleAttr(type, name, val) {
    if (typeof name === "object") {
      for (var key in name) {
        this.styleAttr(type, key, name[key]);
      }
      return this;
    }
    var morpher = new Morphable_default(this._stepper).to(val);
    this.queue(function() {
      morpher = morpher.from(this.element()[type](name));
    }, function(pos) {
      this.element()[type](name, morpher.at(pos));
      return morpher.done();
    });
    return this;
  },
  zoom(level, point2) {
    if (this._tryRetarget("zoom", to, point2))
      return this;
    var morpher = new Morphable_default(this._stepper).to(new SVGNumber_default(level));
    this.queue(function() {
      morpher = morpher.from(this.element().zoom());
    }, function(pos) {
      this.element().zoom(morpher.at(pos), point2);
      return morpher.done();
    }, function(newLevel, newPoint) {
      point2 = newPoint;
      morpher.to(newLevel);
    });
    this._rememberMorpher("zoom", morpher);
    return this;
  },
  transform(transforms2, relative, affine) {
    relative = transforms2.relative || relative;
    if (this._isDeclarative && !relative && this._tryRetarget("transform", transforms2)) {
      return this;
    }
    var isMatrix = Matrix_default.isMatrixLike(transforms2);
    affine = transforms2.affine != null ? transforms2.affine : affine != null ? affine : !isMatrix;
    const morpher = new Morphable_default(this._stepper).type(affine ? TransformBag : Matrix_default);
    let origin;
    let element;
    let current;
    let currentAngle;
    let startTransform;
    function setup() {
      element = element || this.element();
      origin = origin || getOrigin(transforms2, element);
      startTransform = new Matrix_default(relative ? void 0 : element);
      element._addRunner(this);
      if (!relative) {
        element._clearTransformRunnersBefore(this);
      }
    }
    function run(pos) {
      if (!relative)
        this.clearTransform();
      const {x: x3, y: y3} = new Point_default(origin).transform(element._currentTransform(this));
      let target = new Matrix_default({...transforms2, origin: [x3, y3]});
      let start = this._isDeclarative && current ? current : startTransform;
      if (affine) {
        target = target.decompose(x3, y3);
        start = start.decompose(x3, y3);
        const rTarget = target.rotate;
        const rCurrent = start.rotate;
        const possibilities = [rTarget - 360, rTarget, rTarget + 360];
        const distances = possibilities.map((a) => Math.abs(a - rCurrent));
        const shortest = Math.min(...distances);
        const index = distances.indexOf(shortest);
        target.rotate = possibilities[index];
      }
      if (relative) {
        if (!isMatrix) {
          target.rotate = transforms2.rotate || 0;
        }
        if (this._isDeclarative && currentAngle) {
          start.rotate = currentAngle;
        }
      }
      morpher.from(start);
      morpher.to(target);
      const affineParameters = morpher.at(pos);
      currentAngle = affineParameters.rotate;
      current = new Matrix_default(affineParameters);
      this.addTransform(current);
      element._addRunner(this);
      return morpher.done();
    }
    function retarget(newTransforms) {
      if ((newTransforms.origin || "center").toString() !== (transforms2.origin || "center").toString()) {
        origin = getOrigin(transforms2, element);
      }
      transforms2 = {...newTransforms, origin};
    }
    this.queue(setup, run, retarget, true);
    this._isDeclarative && this._rememberMorpher("transform", morpher);
    return this;
  },
  x(x3, relative) {
    return this._queueNumber("x", x3);
  },
  y(y3) {
    return this._queueNumber("y", y3);
  },
  dx(x3 = 0) {
    return this._queueNumberDelta("x", x3);
  },
  dy(y3 = 0) {
    return this._queueNumberDelta("y", y3);
  },
  dmove(x3, y3) {
    return this.dx(x3).dy(y3);
  },
  _queueNumberDelta(method, to2) {
    to2 = new SVGNumber_default(to2);
    if (this._tryRetarget(method, to2))
      return this;
    var morpher = new Morphable_default(this._stepper).to(to2);
    var from2 = null;
    this.queue(function() {
      from2 = this.element()[method]();
      morpher.from(from2);
      morpher.to(from2 + to2);
    }, function(pos) {
      this.element()[method](morpher.at(pos));
      return morpher.done();
    }, function(newTo) {
      morpher.to(from2 + new SVGNumber_default(newTo));
    });
    this._rememberMorpher(method, morpher);
    return this;
  },
  _queueObject(method, to2) {
    if (this._tryRetarget(method, to2))
      return this;
    var morpher = new Morphable_default(this._stepper).to(to2);
    this.queue(function() {
      morpher.from(this.element()[method]());
    }, function(pos) {
      this.element()[method](morpher.at(pos));
      return morpher.done();
    });
    this._rememberMorpher(method, morpher);
    return this;
  },
  _queueNumber(method, value) {
    return this._queueObject(method, new SVGNumber_default(value));
  },
  cx(x3) {
    return this._queueNumber("cx", x3);
  },
  cy(y3) {
    return this._queueNumber("cy", y3);
  },
  move(x3, y3) {
    return this.x(x3).y(y3);
  },
  center(x3, y3) {
    return this.cx(x3).cy(y3);
  },
  size(width3, height3) {
    var box;
    if (!width3 || !height3) {
      box = this._element.bbox();
    }
    if (!width3) {
      width3 = box.width / box.height * height3;
    }
    if (!height3) {
      height3 = box.height / box.width * width3;
    }
    return this.width(width3).height(height3);
  },
  width(width3) {
    return this._queueNumber("width", width3);
  },
  height(height3) {
    return this._queueNumber("height", height3);
  },
  plot(a, b, c, d) {
    if (arguments.length === 4) {
      return this.plot([a, b, c, d]);
    }
    if (this._tryRetarget("plot", a))
      return this;
    var morpher = new Morphable_default(this._stepper).type(this._element.MorphArray).to(a);
    this.queue(function() {
      morpher.from(this._element.array());
    }, function(pos) {
      this._element.plot(morpher.at(pos));
      return morpher.done();
    });
    this._rememberMorpher("plot", morpher);
    return this;
  },
  leading(value) {
    return this._queueNumber("leading", value);
  },
  viewbox(x3, y3, width3, height3) {
    return this._queueObject("viewbox", new Box_default(x3, y3, width3, height3));
  },
  update(o) {
    if (typeof o !== "object") {
      return this.update({
        offset: arguments[0],
        color: arguments[1],
        opacity: arguments[2]
      });
    }
    if (o.opacity != null)
      this.attr("stop-opacity", o.opacity);
    if (o.color != null)
      this.attr("stop-color", o.color);
    if (o.offset != null)
      this.attr("offset", o.offset);
    return this;
  }
});
extend(Runner, {rx, ry, from, to});
register(Runner, "Runner");

// node_modules/@svgdotjs/svg.js/src/elements/Svg.js
var Svg = class extends Container_default {
  constructor(node) {
    super(nodeOrNew("svg", node), node);
    this.namespace();
  }
  isRoot() {
    return !this.node.parentNode || !(this.node.parentNode instanceof globals.window.SVGElement) || this.node.parentNode.nodeName === "#document";
  }
  root() {
    if (this.isRoot())
      return this;
    return super.root();
  }
  namespace() {
    if (!this.isRoot())
      return this.root().namespace();
    return this.attr({xmlns: ns, version: "1.1"}).attr("xmlns:xlink", xlink, xmlns).attr("xmlns:svgjs", svgjs, xmlns);
  }
  defs() {
    if (!this.isRoot())
      return this.root().defs();
    return adopt(this.node.querySelector("defs")) || this.put(new Defs_default());
  }
  parent(type) {
    if (this.isRoot()) {
      return this.node.parentNode.nodeName === "#document" ? null : adopt(this.node.parentNode);
    }
    return super.parent(type);
  }
  clear() {
    while (this.node.hasChildNodes()) {
      this.node.removeChild(this.node.lastChild);
    }
    delete this._defs;
    return this;
  }
};
var Svg_default = Svg;
registerMethods({
  Container: {
    nested: wrapWithAttrCheck(function() {
      return this.put(new Svg());
    })
  }
});
register(Svg, "Svg", true);

// node_modules/@svgdotjs/svg.js/src/elements/Symbol.js
var Symbol = class extends Container_default {
  constructor(node) {
    super(nodeOrNew("symbol", node), node);
  }
};
var Symbol_default = Symbol;
registerMethods({
  Container: {
    symbol: wrapWithAttrCheck(function() {
      return this.put(new Symbol());
    })
  }
});
register(Symbol, "Symbol");

// node_modules/@svgdotjs/svg.js/src/modules/core/textable.js
var textable_exports = {};
__export(textable_exports, {
  length: () => length,
  plain: () => plain
});
function plain(text) {
  if (this._build === false) {
    this.clear();
  }
  this.node.appendChild(globals.document.createTextNode(text));
  return this;
}
function length() {
  return this.node.getComputedTextLength();
}

// node_modules/@svgdotjs/svg.js/src/elements/Text.js
var Text = class extends Shape_default {
  constructor(node) {
    super(nodeOrNew("text", node), node);
    this.dom.leading = new SVGNumber_default(1.3);
    this._rebuild = true;
    this._build = false;
  }
  x(x3, box = this.bbox()) {
    if (x3 == null) {
      return box.x;
    }
    return this.attr("x", this.attr("x") + x3 - box.x);
  }
  y(y3, box = this.bbox()) {
    if (y3 == null) {
      return box.y;
    }
    return this.attr("y", this.attr("y") + y3 - box.y);
  }
  move(x3, y3, box = this.bbox()) {
    return this.x(x3, box).y(y3, box);
  }
  cx(x3, box = this.bbox()) {
    if (x3 == null) {
      return box.cx;
    }
    return this.attr("x", this.attr("x") + x3 - box.cx);
  }
  cy(y3, box = this.bbox()) {
    if (y3 == null) {
      return box.cy;
    }
    return this.attr("y", this.attr("y") + y3 - box.cy);
  }
  center(x3, y3, box = this.bbox()) {
    return this.cx(x3, box).cy(y3, box);
  }
  text(text) {
    if (text === void 0) {
      var children = this.node.childNodes;
      var firstLine = 0;
      text = "";
      for (var i = 0, len = children.length; i < len; ++i) {
        if (children[i].nodeName === "textPath") {
          if (i === 0)
            firstLine = 1;
          continue;
        }
        if (i !== firstLine && children[i].nodeType !== 3 && adopt(children[i]).dom.newLined === true) {
          text += "\n";
        }
        text += children[i].textContent;
      }
      return text;
    }
    this.clear().build(true);
    if (typeof text === "function") {
      text.call(this, this);
    } else {
      text = text.split("\n");
      for (var j = 0, jl = text.length; j < jl; j++) {
        this.tspan(text[j]).newLine();
      }
    }
    return this.build(false).rebuild();
  }
  leading(value) {
    if (value == null) {
      return this.dom.leading;
    }
    this.dom.leading = new SVGNumber_default(value);
    return this.rebuild();
  }
  rebuild(rebuild) {
    if (typeof rebuild === "boolean") {
      this._rebuild = rebuild;
    }
    if (this._rebuild) {
      var self = this;
      var blankLineOffset = 0;
      var leading = this.dom.leading;
      this.each(function() {
        var fontSize = globals.window.getComputedStyle(this.node).getPropertyValue("font-size");
        var dy = leading * new SVGNumber_default(fontSize);
        if (this.dom.newLined) {
          this.attr("x", self.attr("x"));
          if (this.text() === "\n") {
            blankLineOffset += dy;
          } else {
            this.attr("dy", dy + blankLineOffset);
            blankLineOffset = 0;
          }
        }
      });
      this.fire("rebuild");
    }
    return this;
  }
  build(build) {
    this._build = !!build;
    return this;
  }
  setData(o) {
    this.dom = o;
    this.dom.leading = new SVGNumber_default(o.leading || 1.3);
    return this;
  }
};
var Text_default = Text;
extend(Text, textable_exports);
registerMethods({
  Container: {
    text: wrapWithAttrCheck(function(text) {
      return this.put(new Text()).text(text);
    }),
    plain: wrapWithAttrCheck(function(text) {
      return this.put(new Text()).plain(text);
    })
  }
});
register(Text, "Text");

// node_modules/@svgdotjs/svg.js/src/elements/Tspan.js
var Tspan = class extends Text_default {
  constructor(node) {
    super(nodeOrNew("tspan", node), node);
  }
  text(text) {
    if (text == null)
      return this.node.textContent + (this.dom.newLined ? "\n" : "");
    typeof text === "function" ? text.call(this, this) : this.plain(text);
    return this;
  }
  dx(dx) {
    return this.attr("dx", dx);
  }
  dy(dy) {
    return this.attr("dy", dy);
  }
  x(x3) {
    return this.attr("x", x3);
  }
  y(y3) {
    return this.attr("x", y3);
  }
  move(x3, y3) {
    return this.x(x3).y(y3);
  }
  newLine() {
    var t = this.parent(Text_default);
    this.dom.newLined = true;
    var fontSize = globals.window.getComputedStyle(this.node).getPropertyValue("font-size");
    var dy = t.dom.leading * new SVGNumber_default(fontSize);
    return this.dy(dy).attr("x", t.x());
  }
};
var Tspan_default = Tspan;
extend(Tspan, textable_exports);
registerMethods({
  Tspan: {
    tspan: wrapWithAttrCheck(function(text) {
      var tspan = new Tspan();
      if (!this._build) {
        this.clear();
      }
      this.node.appendChild(tspan.node);
      return tspan.text(text);
    })
  }
});
register(Tspan, "Tspan");

// node_modules/@svgdotjs/svg.js/src/elements/ClipPath.js
var ClipPath = class extends Container_default {
  constructor(node) {
    super(nodeOrNew("clipPath", node), node);
  }
  remove() {
    this.targets().forEach(function(el) {
      el.unclip();
    });
    return super.remove();
  }
  targets() {
    return baseFind('svg [clip-path*="' + this.id() + '"]');
  }
};
var ClipPath_default = ClipPath;
registerMethods({
  Container: {
    clip: wrapWithAttrCheck(function() {
      return this.defs().put(new ClipPath());
    })
  },
  Element: {
    clipWith(element) {
      const clipper = element instanceof ClipPath ? element : this.parent().clip().add(element);
      return this.attr("clip-path", 'url("#' + clipper.id() + '")');
    },
    unclip() {
      return this.attr("clip-path", null);
    },
    clipper() {
      return this.reference("clip-path");
    }
  }
});
register(ClipPath, "ClipPath");

// node_modules/@svgdotjs/svg.js/src/elements/ForeignObject.js
var ForeignObject = class extends Element_default {
  constructor(node) {
    super(nodeOrNew("foreignObject", node), node);
  }
};
var ForeignObject_default = ForeignObject;
registerMethods({
  Container: {
    foreignObject: wrapWithAttrCheck(function(width3, height3) {
      return this.put(new ForeignObject()).size(width3, height3);
    })
  }
});
register(ForeignObject, "ForeignObject");

// node_modules/@svgdotjs/svg.js/src/elements/G.js
var G = class extends Container_default {
  constructor(node) {
    super(nodeOrNew("g", node), node);
  }
  x(x3, box = this.bbox()) {
    if (x3 == null)
      return box.x;
    return this.move(x3, box.y, box);
  }
  y(y3, box = this.bbox()) {
    if (y3 == null)
      return box.y;
    return this.move(box.x, y3, box);
  }
  move(x3 = 0, y3 = 0, box = this.bbox()) {
    const dx = x3 - box.x;
    const dy = y3 - box.y;
    return this.dmove(dx, dy);
  }
  dx(dx) {
    return this.dmove(dx, 0);
  }
  dy(dy) {
    return this.dmove(0, dy);
  }
  dmove(dx, dy) {
    this.children().forEach((child, i) => {
      const bbox2 = child.bbox();
      const m = new Matrix_default(child);
      const matrix = m.translate(dx, dy).transform(m.inverse());
      const p = new Point_default(bbox2.x, bbox2.y).transform(matrix);
      child.move(p.x, p.y);
    });
    return this;
  }
  width(width3, box = this.bbox()) {
    if (width3 == null)
      return box.width;
    return this.size(width3, box.height, box);
  }
  height(height3, box = this.bbox()) {
    if (height3 == null)
      return box.height;
    return this.size(box.width, height3, box);
  }
  size(width3, height3, box = this.bbox()) {
    const p = proportionalSize(this, width3, height3, box);
    const scaleX = p.width / box.width;
    const scaleY = p.height / box.height;
    this.children().forEach((child, i) => {
      const o = new Point_default(box).transform(new Matrix_default(child).inverse());
      child.scale(scaleX, scaleY, o.x, o.y);
    });
    return this;
  }
};
var G_default = G;
registerMethods({
  Container: {
    group: wrapWithAttrCheck(function() {
      return this.put(new G());
    })
  }
});
register(G, "G");

// node_modules/@svgdotjs/svg.js/src/elements/A.js
var A = class extends Container_default {
  constructor(node) {
    super(nodeOrNew("a", node), node);
  }
  to(url) {
    return this.attr("href", url, xlink);
  }
  target(target) {
    return this.attr("target", target);
  }
};
var A_default = A;
registerMethods({
  Container: {
    link: wrapWithAttrCheck(function(url) {
      return this.put(new A()).to(url);
    })
  },
  Element: {
    linkTo: function(url) {
      var link = new A();
      if (typeof url === "function") {
        url.call(link, link);
      } else {
        link.to(url);
      }
      return this.parent().put(link).put(this);
    }
  }
});
register(A, "A");

// node_modules/@svgdotjs/svg.js/src/elements/Mask.js
var Mask = class extends Container_default {
  constructor(node) {
    super(nodeOrNew("mask", node), node);
  }
  remove() {
    this.targets().forEach(function(el) {
      el.unmask();
    });
    return super.remove();
  }
  targets() {
    return baseFind('svg [mask*="' + this.id() + '"]');
  }
};
var Mask_default = Mask;
registerMethods({
  Container: {
    mask: wrapWithAttrCheck(function() {
      return this.defs().put(new Mask());
    })
  },
  Element: {
    maskWith(element) {
      var masker = element instanceof Mask ? element : this.parent().mask().add(element);
      return this.attr("mask", 'url("#' + masker.id() + '")');
    },
    unmask() {
      return this.attr("mask", null);
    },
    masker() {
      return this.reference("mask");
    }
  }
});
register(Mask, "Mask");

// node_modules/@svgdotjs/svg.js/src/elements/Style.js
function cssRule(selector, rule) {
  if (!selector)
    return "";
  if (!rule)
    return selector;
  var ret = selector + "{";
  for (var i in rule) {
    ret += unCamelCase(i) + ":" + rule[i] + ";";
  }
  ret += "}";
  return ret;
}
var Style = class extends Element_default {
  constructor(node) {
    super(nodeOrNew("style", node), node);
  }
  addText(w = "") {
    this.node.textContent += w;
    return this;
  }
  font(name, src, params = {}) {
    return this.rule("@font-face", {
      fontFamily: name,
      src,
      ...params
    });
  }
  rule(selector, obj) {
    return this.addText(cssRule(selector, obj));
  }
};
var Style_default = Style;
registerMethods("Dom", {
  style: wrapWithAttrCheck(function(selector, obj) {
    return this.put(new Style()).rule(selector, obj);
  }),
  fontface: wrapWithAttrCheck(function(name, src, params) {
    return this.put(new Style()).font(name, src, params);
  })
});
register(Style, "Style");

// node_modules/@svgdotjs/svg.js/src/elements/TextPath.js
var TextPath = class extends Text_default {
  constructor(node) {
    super(nodeOrNew("textPath", node), node);
  }
  array() {
    var track = this.track();
    return track ? track.array() : null;
  }
  plot(d) {
    var track = this.track();
    var pathArray = null;
    if (track) {
      pathArray = track.plot(d);
    }
    return d == null ? pathArray : this;
  }
  track() {
    return this.reference("href");
  }
};
var TextPath_default = TextPath;
registerMethods({
  Container: {
    textPath: wrapWithAttrCheck(function(text, path) {
      if (!(text instanceof Text_default)) {
        text = this.text(text);
      }
      return text.path(path);
    })
  },
  Text: {
    path: wrapWithAttrCheck(function(track, importNodes = true) {
      var textPath = new TextPath();
      if (!(track instanceof Path_default)) {
        track = this.defs().path(track);
      }
      textPath.attr("href", "#" + track, xlink);
      let node;
      if (importNodes) {
        while (node = this.node.firstChild) {
          textPath.node.appendChild(node);
        }
      }
      return this.put(textPath);
    }),
    textPath() {
      return this.findOne("textPath");
    }
  },
  Path: {
    text: wrapWithAttrCheck(function(text) {
      if (!(text instanceof Text_default)) {
        text = new Text_default().addTo(this.parent()).text(text);
      }
      return text.path(this);
    }),
    targets() {
      return baseFind('svg [href*="' + this.id() + '"]');
    }
  }
});
TextPath.prototype.MorphArray = PathArray_default;
register(TextPath, "TextPath");

// node_modules/@svgdotjs/svg.js/src/elements/Use.js
var Use = class extends Shape_default {
  constructor(node) {
    super(nodeOrNew("use", node), node);
  }
  element(element, file) {
    return this.attr("href", (file || "") + "#" + element, xlink);
  }
};
var Use_default = Use;
registerMethods({
  Container: {
    use: wrapWithAttrCheck(function(element, file) {
      return this.put(new Use()).element(element, file);
    })
  }
});
register(Use, "Use");

// node_modules/@svgdotjs/svg.js/src/main.js
var SVG = makeInstance;
extend([
  Svg_default,
  Symbol_default,
  Image_default,
  Pattern_default,
  Marker_default
], getMethodsFor("viewbox"));
extend([
  Line_default,
  Polyline_default,
  Polygon_default,
  Path_default
], getMethodsFor("marker"));
extend(Text_default, getMethodsFor("Text"));
extend(Path_default, getMethodsFor("Path"));
extend(Defs_default, getMethodsFor("Defs"));
extend([
  Text_default,
  Tspan_default
], getMethodsFor("Tspan"));
extend([
  Rect_default,
  Ellipse_default,
  Circle_default,
  Gradient_default
], getMethodsFor("radius"));
extend(EventTarget_default, getMethodsFor("EventTarget"));
extend(Dom_default, getMethodsFor("Dom"));
extend(Element_default, getMethodsFor("Element"));
extend(Shape_default, getMethodsFor("Shape"));
extend(Container_default, getMethodsFor("Container"));
extend(Runner_default, getMethodsFor("Runner"));
List_default.extend(getMethodNames());
registerMorphableType([
  SVGNumber_default,
  Color_default,
  Box_default,
  Matrix_default,
  SVGArray_default,
  PointArray_default,
  PathArray_default
]);
makeMorphable();
export {
  A_default as A,
  Animator_default as Animator,
  SVGArray_default as Array,
  Box_default as Box,
  Circle_default as Circle,
  ClipPath_default as ClipPath,
  Color_default as Color,
  Container_default as Container,
  Controller,
  Defs_default as Defs,
  Dom_default as Dom,
  Ease,
  Element_default as Element,
  Ellipse_default as Ellipse,
  EventTarget_default as EventTarget,
  ForeignObject_default as ForeignObject,
  G_default as G,
  Gradient_default as Gradient,
  Image_default as Image,
  Line_default as Line,
  List_default as List,
  Marker_default as Marker,
  Mask_default as Mask,
  Matrix_default as Matrix,
  Morphable_default as Morphable,
  NonMorphable,
  SVGNumber_default as Number,
  ObjectBag,
  PID,
  Path_default as Path,
  PathArray_default as PathArray,
  Pattern_default as Pattern,
  Point_default as Point,
  PointArray_default as PointArray,
  Polygon_default as Polygon,
  Polyline_default as Polyline,
  Queue_default as Queue,
  Rect_default as Rect,
  Runner_default as Runner,
  SVG,
  Shape_default as Shape,
  Spring,
  Stop_default as Stop,
  Style_default as Style,
  Svg_default as Svg,
  Symbol_default as Symbol,
  Text_default as Text,
  TextPath_default as TextPath,
  Timeline_default as Timeline,
  TransformBag,
  Tspan_default as Tspan,
  Use_default as Use,
  adopt,
  assignNewId,
  create,
  defaults_exports as defaults,
  dispatch,
  easing,
  eid,
  extend,
  baseFind as find,
  getClass,
  invent,
  makeInstance,
  makeMorphable,
  mockAdopt,
  namespaces_exports as namespaces,
  nodeOrNew,
  off,
  on,
  parser,
  regex_exports as regex,
  register,
  registerMorphableType,
  registerWindow,
  root,
  utils_exports as utils,
  wrapWithAttrCheck
};
//# sourceMappingURL=@svgdotjs_svg_js.js.map
